<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic Assessment</title>
    <style>
        :root {
            --spirit: #805ad5;
            --soul: #3182ce;
            --body: #38a169;
            --bg: #0d1117;
            --card: #161b22;
            --text: #e2e8f0;
            --text-muted: #6e7681;
            --border: #30363d;
            --accent: #58a6ff;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 8px; }
        .subtitle { color: var(--text-muted); margin-bottom: 24px; }
        
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }
        .card h2, .card h3 { font-size: 1.1rem; margin-bottom: 16px; color: var(--text); }
        .card h3 { font-size: 0.8rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px; }
        
        .dim-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .dim-btn { padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: transparent; color: var(--text); cursor: pointer; transition: all 0.2s; text-align: center; }
        .dim-btn:hover { border-color: var(--accent); background: rgba(88, 166, 255, 0.1); }
        .dim-btn .code { font-size: 1.5rem; font-weight: bold; display: block; }
        .dim-btn .name { font-size: 0.85rem; color: var(--text-muted); }
        .dim-btn.spirit .code { color: var(--spirit); }
        .dim-btn.soul .code { color: var(--soul); }
        .dim-btn.body .code { color: var(--body); }
        
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin-bottom: 20px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); transition: width 0.3s; }
        .cell-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border); }
        .cell-label { font-weight: bold; }
        .cell-layer { color: var(--text-muted); font-size: 0.9rem; }
        .question-counter { color: var(--text-muted); font-size: 0.85rem; }
        .probe-mode { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; margin-left: 8px; text-transform: uppercase; }
        .probe-mode.quick { background: rgba(88, 166, 255, 0.2); color: var(--accent); }
        .probe-mode.full { background: rgba(104, 211, 145, 0.2); color: #68d391; }
        .question-text { font-size: 1.1rem; line-height: 1.6; margin-bottom: 20px; }
        .question-voice { color: var(--text-muted); font-size: 0.8rem; font-style: italic; margin-bottom: 16px; }
        .answers { display: flex; flex-direction: column; gap: 10px; }
        .answer-btn { padding: 14px 16px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text); cursor: pointer; text-align: left; transition: all 0.2s; font-size: 0.95rem; line-height: 1.4; }
        .answer-btn:hover { border-color: var(--accent); background: rgba(88, 166, 255, 0.1); }
        .answer-btn .score-label { display: inline-block; width: 24px; font-weight: bold; color: var(--accent); }
        
        .processing { text-align: center; padding: 40px; }
        .processing .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .probe-trail { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 16px; }
        .probe-item { padding: 4px 10px; border-radius: 4px; font-size: 0.8rem; font-weight: bold; }
        .probe-item.strong { background: rgba(104, 211, 145, 0.2); color: #68d391; }
        .probe-item.weak { background: rgba(252, 129, 129, 0.2); color: #fc8181; }
        .probe-item.current { background: rgba(88, 166, 255, 0.2); color: var(--accent); }
        
        .results-layout { display: grid; grid-template-columns: 1fr 280px; gap: 24px; }
        @media (max-width: 800px) { .results-layout { grid-template-columns: 1fr; } }
        .result-summary { text-align: center; margin-bottom: 24px; }
        .result-summary h3 { font-size: 1.3rem; margin-bottom: 8px; text-transform: none; letter-spacing: normal; }
        .result-summary .break-info { font-size: 1.1rem; color: var(--text-muted); }
        .result-summary .break-info strong { color: #fc8181; }
        .result-summary .break-info.solid strong { color: #68d391; }
        .result-stats { font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; }
        
        .btn { padding: 12px 24px; border: none; border-radius: 8px; background: var(--accent); color: #fff; font-size: 1rem; cursor: pointer; transition: opacity 0.2s; }
        .btn:hover { opacity: 0.9; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-primary { background: #68d391; color: #0d1117; font-weight: bold; }
        .btn-row { display: flex; gap: 12px; justify-content: center; margin-top: 20px; }
        
        .wheel-container { display: flex; justify-content: center; align-items: center; }
        #wheel { max-width: 100%; height: auto; }
        
        .sidebar { display: flex; flex-direction: column; gap: 16px; }
        .sidebar .card { margin-bottom: 0; padding: 16px; }
        
        .hover-info { min-height: 80px; }
        .hover-info .cell-name { font-size: 1.2rem; font-weight: bold; margin-bottom: 4px; }
        .hover-info .cell-detail { color: var(--text-muted); font-size: 0.85rem; margin-bottom: 8px; }
        .hover-info .cell-score { font-size: 1.5rem; font-weight: bold; }
        .hover-info .cell-status { font-size: 0.85rem; margin-top: 4px; }
        .hover-info .cell-status.strong { color: #68d391; }
        .hover-info .cell-status.weak { color: #fc8181; }
        
        .category-scores { display: flex; flex-direction: column; gap: 8px; }
        .category-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(0,0,0,0.3); border-radius: 6px; }
        .category-row .cat-name { font-weight: bold; font-size: 0.85rem; }
        .category-row .cat-name.spirit { color: var(--spirit); }
        .category-row .cat-name.soul { color: var(--soul); }
        .category-row .cat-name.body { color: var(--body); }
        .category-row .cat-score { font-weight: bold; }
        .category-row .cat-score.strong { color: #68d391; }
        .category-row .cat-score.weak { color: #fc8181; }
        
        .overall-row { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .overall-row .label { font-weight: bold; color: var(--text); }
        .overall-row .score { font-size: 1.2rem; font-weight: bold; }
        .overall-row .score.strong { color: #68d391; }
        .overall-row .score.weak { color: #fc8181; }
        
        .breaks-list { display: flex; flex-direction: column; gap: 8px; }
        .break-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px; cursor: pointer; transition: background 0.15s; }
        .break-item:hover { background: rgba(255,255,255,0.1); }
        .break-item .dim { font-weight: bold; }
        .break-item .dim.spirit { color: var(--spirit); }
        .break-item .dim.soul { color: var(--soul); }
        .break-item .dim.body { color: var(--body); }
        .break-item .layer { color: var(--text-muted); font-size: 0.85rem; }
        .break-item .layer.solid { color: #68d391; }
        .break-item .layer.crisis { color: #fc8181; }
        
        .legend { display: flex; flex-direction: column; gap: 8px; }
        .legend-row { display: flex; align-items: center; gap: 8px; }
        .legend-label { width: 50px; font-size: 0.75rem; }
        .legend-gradient { flex: 1; height: 12px; border-radius: 4px; }
        .legend-gradient.spirit { background: linear-gradient(to right, #000, #805ad5); }
        .legend-gradient.soul { background: linear-gradient(to right, #000, #3182ce); }
        .legend-gradient.body { background: linear-gradient(to right, #000, #38a169); }
        .legend-labels { display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-muted); margin-top: 4px; margin-left: 58px; }
        
        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal { background: var(--card); border: 1px solid var(--border); border-radius: 16px; max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto; }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h2 { font-size: 1.2rem; margin: 0; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close:hover { color: var(--text); }
        .modal-body { padding: 24px; }
        .modal-section { margin-bottom: 20px; }
        .modal-section:last-child { margin-bottom: 0; }
        .modal-section h4 { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .modal-section p { line-height: 1.6; }
        
        .focus-cell { display: flex; align-items: center; gap: 12px; padding: 16px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 16px; }
        .focus-cell .cell-code { font-size: 2rem; font-weight: bold; }
        .focus-cell .cell-code.spirit { color: var(--spirit); }
        .focus-cell .cell-code.soul { color: var(--soul); }
        .focus-cell .cell-code.body { color: var(--body); }
        .focus-cell .cell-info-text { flex: 1; }
        .focus-cell .cell-name { font-weight: bold; font-size: 1.1rem; }
        .focus-cell .cell-layer { color: var(--text-muted); font-size: 0.85rem; }
        .focus-cell .cell-score { font-size: 1.5rem; font-weight: bold; }
        .focus-cell .cell-score.weak { color: #fc8181; }
        
        .advice-box { font-size: 1rem; line-height: 1.7; padding: 16px; background: rgba(88, 166, 255, 0.1); border-radius: 8px; border-left: 3px solid var(--accent); }
        .scripture-box { margin-top: 16px; padding: 16px; background: rgba(104, 211, 145, 0.1); border-radius: 8px; border-left: 3px solid #68d391; }
        .scripture-text { font-style: italic; font-size: 1rem; line-height: 1.6; margin-bottom: 8px; }
        .scripture-ref { font-size: 0.85rem; color: #68d391; font-weight: bold; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Diagnostic Assessment</h1>
        <p class="subtitle">Find your break points efficiently</p>
        
        <div id="phase-select" class="card">
            <h2>Choose a dimension to assess</h2>
            <div class="dim-grid" id="dim-grid"></div>
        </div>
        
        <div id="phase-questions" class="card hidden">
            <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width: 0%"></div></div>
            <div class="cell-info">
                <div>
                    <span class="cell-label" id="cell-label">A1</span>
                    <span class="cell-layer" id="cell-layer">Order</span>
                    <span class="probe-mode" id="probe-mode">quick</span>
                </div>
                <span class="question-counter" id="question-counter">Q1 of 2</span>
            </div>
            <div class="question-voice" id="question-voice"></div>
            <div class="question-text" id="question-text"></div>
            <div class="answers" id="answers"></div>
            <div class="probe-trail" id="probe-trail"></div>
        </div>
        
        <div id="phase-processing" class="card hidden">
            <div class="processing"><div class="spinner"></div><p>Analyzing results...</p></div>
        </div>
        
        <div id="phase-results" class="hidden">
            <div class="results-layout">
                <div class="wheel-section">
                    <div class="card">
                        <div class="result-summary">
                            <h3 id="result-title">Assessment Complete</h3>
                            <p class="break-info" id="break-info"></p>
                            <p class="result-stats" id="result-stats"></p>
                        </div>
                        <div class="wheel-container">
                            <svg id="wheel" viewBox="-260 -260 520 520" width="400" height="400"></svg>
                        </div>
                        <div class="btn-row">
                            <button class="btn btn-primary" id="whats-next-btn" onclick="showWhatsNext()">What's Next?</button>
                            <button class="btn btn-secondary" onclick="restart()">Start Over</button>
                        </div>
                    </div>
                </div>
                <div class="sidebar">
                    <div class="card hover-info" id="hover-info">
                        <h3>Cell Details</h3>
                        <div class="cell-name" id="hover-cell-name">Hover over wheel</div>
                        <div class="cell-detail" id="hover-cell-detail">—</div>
                        <div class="cell-score" id="hover-cell-score">—</div>
                        <div class="cell-status" id="hover-cell-status"></div>
                    </div>
                    <div class="card">
                        <h3>Limiting Factors</h3>
                        <div class="category-scores" id="category-scores"></div>
                        <div class="overall-row">
                            <span class="label">Overall</span>
                            <span class="score" id="overall-score">—</span>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Break Points</h3>
                        <div class="breaks-list" id="breaks-list"></div>
                    </div>
                    <div class="card">
                        <h3>Legend</h3>
                        <div class="legend">
                            <div class="legend-row"><span class="legend-label" style="color: var(--spirit)">Spirit</span><div class="legend-gradient spirit"></div></div>
                            <div class="legend-row"><span class="legend-label" style="color: var(--soul)">Soul</span><div class="legend-gradient soul"></div></div>
                            <div class="legend-row"><span class="legend-label" style="color: var(--body)">Body</span><div class="legend-gradient body"></div></div>
                        </div>
                        <div class="legend-labels"><span>2 (Crisis)</span><span>10 (Exceptional)</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="whats-next-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h2>What's Next?</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body"></div>
        </div>
    </div>
    
    <script>
    const DIMENSIONS = {
        A: { name: 'Communion', category: 'Spirit' },
        B: { name: 'Conscience', category: 'Spirit' },
        C: { name: 'Holiness', category: 'Spirit' },
        D: { name: 'Mind', category: 'Soul' },
        E: { name: 'Will', category: 'Soul' },
        F: { name: 'Emotions', category: 'Soul' },
        G: { name: 'Sustenance', category: 'Body' },
        H: { name: 'Capability', category: 'Body' },
        I: { name: 'Wholeness', category: 'Body' },
    };
    
    const LAYERS = { 1: 'Order', 2: 'Causality', 3: 'Responsibility', 4: 'Discipline', 5: 'Skill', 6: 'Resources', 7: 'Fellowship', 8: 'Sacrifice' };
    const CATEGORIES = { Spirit: ['A', 'B', 'C'], Soul: ['D', 'E', 'F'], Body: ['G', 'H', 'I'] };
    const LIKERT_SCALE = { 1: 'Strongly Disagree', 2: 'Disagree', 3: 'Neutral / Unsure', 4: 'Agree', 5: 'Strongly Agree' };
    const DIM_ORDER = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    const THRESHOLD = 3.5, DISPLAY_THRESHOLD = 7, DATA_PATH = '/data/questions/';
    const QUICK_PROBE_COUNT = 2, QUICK_PROBE_TIEBREAK = 1, STRONG_THRESHOLD = 4, WEAK_THRESHOLD = 2;
    
    let currentDim = null, scores = {}, fullProbes = new Set(), probeTrail = [];
    let currentCell = null, currentQuestionIdx = 0, currentAnswers = [], questionsAnswered = 0;
    let breakLayer = null, fullData = null, highlightMarker = null, breakCellData = null;
    let searchState = { phase: 'initial', probeQueue: [] };
    
    function showPhase(phase) {
        document.querySelectorAll('#phase-select, #phase-questions, #phase-processing, #phase-results').forEach(el => el.classList.add('hidden'));
        document.getElementById(`phase-${phase}`).classList.remove('hidden');
    }
    
    function initDimensionSelect() {
        const grid = document.getElementById('dim-grid');
        grid.innerHTML = '';
        DIM_ORDER.forEach(code => {
            const info = DIMENSIONS[code];
            const btn = document.createElement('button');
            btn.className = `dim-btn ${info.category.toLowerCase()}`;
            btn.innerHTML = `<span class="code">${code}</span><span class="name">${info.name}</span>`;
            btn.onclick = () => selectDimension(code);
            grid.appendChild(btn);
        });
    }
    
    function selectDimension(dim) {
        currentDim = dim; scores = {}; fullProbes = new Set(); probeTrail = [];
        questionsAnswered = 0; breakLayer = null; breakCellData = null;
        searchState = { phase: 'initial', probeQueue: [3, 6] };
        showPhase('questions');
        probeNextLayer();
    }
    
    async function probeNextLayer() {
        const nextLayer = determineNextProbe();
        if (nextLayer === null) {
            if (breakLayer !== null && !fullProbes.has(breakLayer)) {
                await loadCell(currentDim, breakLayer, true);
                return;
            }
            finishAssessment();
            return;
        }
        await loadCell(currentDim, nextLayer, false);
    }
    
    function determineNextProbe() {
        if (searchState.phase === 'initial') {
            if (searchState.probeQueue.length > 0) return searchState.probeQueue.shift();
            searchState.phase = 'narrowing';
            return determineNextProbe();
        }
        if (searchState.phase === 'narrowing') {
            const l3Strong = scores[3] >= THRESHOLD, l6Strong = scores[6] >= THRESHOLD;
            if (l3Strong && l6Strong) {
                if (scores[7] === undefined) return 7;
                if (scores[8] === undefined) return 8;
                breakLayer = null;
            } else if (!l3Strong && !l6Strong) {
                if (scores[2] === undefined) return 2;
                if (scores[1] === undefined) return 1;
                if (scores[1] >= THRESHOLD) breakLayer = 2;
                else if (scores[2] >= THRESHOLD) breakLayer = 3;
                else breakLayer = 1;
            } else if (l3Strong && !l6Strong) {
                if (scores[4] === undefined) return 4;
                if (scores[5] === undefined) return 5;
                if (scores[4] >= THRESHOLD && scores[5] >= THRESHOLD) breakLayer = 6;
                else if (scores[4] >= THRESHOLD) breakLayer = 5;
                else breakLayer = 4;
            } else {
                if (scores[2] === undefined) return 2;
                if (scores[1] === undefined) return 1;
                if (scores[4] === undefined) return 4;
                if (scores[5] === undefined) return 5;
                for (let l = 1; l <= 8; l++) {
                    if (scores[l] !== undefined && scores[l] < THRESHOLD) { breakLayer = l; break; }
                }
            }
            searchState.phase = 'confirming';
            return determineNextProbe();
        }
        if (searchState.phase === 'confirming') {
            if (breakLayer !== null && breakLayer > 1) {
                const floorLayer = breakLayer - 1;
                if (scores[floorLayer] === undefined) return floorLayer;
            }
        }
        return null;
    }
    
    async function loadCell(dim, layer, isFullProbe) {
        const url = `${DATA_PATH}${dim}${layer}.json`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load ${url}`);
            const cellData = await response.json();
            currentCell = { dim, layer, questions: cellData.questions, layerName: LAYERS[layer], isFullProbe, rawData: cellData };
            currentQuestionIdx = 0; currentAnswers = [];
            displayQuestion();
            updateProbeTrail();
        } catch (error) {
            console.error('Error loading cell:', error);
            recordCellScore(layer, 3.0, isFullProbe, null);
            probeNextLayer();
        }
    }
    
    function getQuestionsToAsk() {
        if (currentCell.isFullProbe) return currentCell.questions.length;
        if (currentAnswers.length < QUICK_PROBE_COUNT) return QUICK_PROBE_COUNT;
        const allStrong = currentAnswers.every(a => a >= STRONG_THRESHOLD);
        const allWeak = currentAnswers.every(a => a <= WEAK_THRESHOLD);
        if (allStrong || allWeak) return QUICK_PROBE_COUNT;
        return QUICK_PROBE_COUNT + QUICK_PROBE_TIEBREAK;
    }
    
    function displayQuestion() {
        const q = currentCell.questions[currentQuestionIdx];
        const questionsToAsk = getQuestionsToAsk();
        document.getElementById('cell-label').textContent = `${currentCell.dim}${currentCell.layer}: ${DIMENSIONS[currentCell.dim].name}`;
        document.getElementById('cell-layer').textContent = `Layer ${currentCell.layer}: ${currentCell.layerName}`;
        const modeEl = document.getElementById('probe-mode');
        modeEl.textContent = currentCell.isFullProbe ? 'full' : 'quick';
        modeEl.className = `probe-mode ${currentCell.isFullProbe ? 'full' : 'quick'}`;
        document.getElementById('question-counter').textContent = `Q${currentQuestionIdx + 1} of ${questionsToAsk}`;
        document.getElementById('question-voice').textContent = q.voice ? `Voice: ${q.voice}` : '';
        document.getElementById('question-text').textContent = q.text;
        const answersEl = document.getElementById('answers');
        answersEl.innerHTML = '';
        const hasCustomAnswers = q.answers && typeof q.answers === 'object';
        for (let i = 1; i <= 5; i++) {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            const answerText = hasCustomAnswers ? (q.answers[i] || q.answers[String(i)] || LIKERT_SCALE[i]) : LIKERT_SCALE[i];
            btn.innerHTML = `<span class="score-label">${i}.</span> ${answerText}`;
            btn.onclick = () => selectAnswer(i);
            answersEl.appendChild(btn);
        }
        const progress = Math.min(100, (questionsAnswered / 15) * 100);
        document.getElementById('progress-fill').style.width = `${progress}%`;
    }
    
    function selectAnswer(score) {
        currentAnswers.push(score); questionsAnswered++; currentQuestionIdx++;
        const questionsToAsk = getQuestionsToAsk();
        if (currentQuestionIdx < questionsToAsk && currentQuestionIdx < currentCell.questions.length) {
            displayQuestion();
        } else {
            const avg = currentAnswers.reduce((a, b) => a + b, 0) / currentAnswers.length;
            recordCellScore(currentCell.layer, avg, currentCell.isFullProbe, currentCell.rawData);
            probeNextLayer();
        }
    }
    
    function recordCellScore(layer, score, isFullProbe, rawData) {
        scores[layer] = score;
        if (isFullProbe) { fullProbes.add(layer); if (rawData) breakCellData = rawData; }
        probeTrail.push({ layer, score, status: score >= THRESHOLD ? 'strong' : 'weak', mode: isFullProbe ? 'full' : 'quick' });
    }
    
    function updateProbeTrail() {
        const trailEl = document.getElementById('probe-trail');
        trailEl.innerHTML = '';
        probeTrail.forEach(p => {
            const item = document.createElement('span');
            item.className = `probe-item ${p.status}`;
            item.textContent = `L${p.layer}: ${(p.score * 2).toFixed(1)}`;
            if (p.mode === 'full') item.textContent += '★';
            trailEl.appendChild(item);
        });
        if (currentCell) {
            const current = document.createElement('span');
            current.className = 'probe-item current';
            current.textContent = `L${currentCell.layer}...`;
            trailEl.appendChild(current);
        }
    }
    
    function findBreakPoint() {
        let floor = 0, bp = null;
        for (let layer = 1; layer <= 8; layer++) {
            if (scores[layer] !== undefined) {
                if (scores[layer] >= THRESHOLD) floor = layer;
                else if (bp === null) bp = layer;
            }
        }
        if (bp === null && floor < 8) {
            for (let layer = floor + 1; layer <= 8; layer++) {
                if (scores[layer] !== undefined && scores[layer] < THRESHOLD) { bp = layer; break; }
            }
        }
        if (bp === null && floor > 0) return { floor: 8, break: null };
        if (floor === 0 && (scores[1] === undefined || scores[1] < THRESHOLD)) return { floor: 0, break: 1 };
        return { floor, break: bp };
    }
    
    function finishAssessment() {
        showPhase('processing');
        fillMissingLayers();
        setTimeout(() => { showPhase('results'); displayResults(); }, 800);
    }
    
    function fillMissingLayers() {
        for (let layer = 1; layer <= 8; layer++) {
            if (scores[layer] === undefined) {
                let below = null, above = null;
                for (let l = layer - 1; l >= 1; l--) { if (scores[l] !== undefined) { below = scores[l]; break; } }
                for (let l = layer + 1; l <= 8; l++) { if (scores[l] !== undefined) { above = scores[l]; break; } }
                if (below !== null && above !== null) scores[layer] = (below + above) / 2;
                else if (below !== null) scores[layer] = below * 0.9;
                else if (above !== null) scores[layer] = Math.min(5, above * 1.1);
                else scores[layer] = 3.0;
            }
        }
    }
    
    function displayResults() {
        const breakInfo = findBreakPoint();
        const titleEl = document.getElementById('result-title');
        const infoEl = document.getElementById('break-info');
        const statsEl = document.getElementById('result-stats');
        const whatsNextBtn = document.getElementById('whats-next-btn');
        
        if (breakInfo.break === null) {
            titleEl.textContent = `${currentDim}: ${DIMENSIONS[currentDim].name} — Solid`;
            infoEl.className = 'break-info solid';
            infoEl.innerHTML = `<strong>No break point</strong> — strong through all layers`;
            whatsNextBtn.classList.add('hidden');
        } else {
            titleEl.textContent = `${currentDim}: ${DIMENSIONS[currentDim].name}`;
            infoEl.className = 'break-info';
            infoEl.innerHTML = `Break at <strong>L${breakInfo.break} ${LAYERS[breakInfo.break]}</strong> — focus here`;
            whatsNextBtn.classList.remove('hidden');
        }
        statsEl.textContent = `${questionsAnswered} questions answered`;
        
        fullData = {};
        DIM_ORDER.forEach(dim => { fullData[dim] = {}; for (let layer = 1; layer <= 8; layer++) fullData[dim][layer] = scores[layer]; });
        renderWheel(fullData);
        renderSidebar(fullData);
    }
    
    // What's Next Modal
    async function showWhatsNext() {
        const breakInfo = findBreakPoint();
        if (breakInfo.break === null) return;
        
        const modal = document.getElementById('whats-next-modal');
        const modalBody = document.getElementById('modal-body');
        
        if (!breakCellData) {
            try {
                const url = `${DATA_PATH}${currentDim}${breakInfo.break}.json`;
                const response = await fetch(url);
                breakCellData = await response.json();
            } catch (error) {
                modalBody.innerHTML = '<p>Unable to load recommendations.</p>';
                modal.classList.remove('hidden');
                return;
            }
        }
        
        const info = DIMENSIONS[currentDim];
        const score = scores[breakInfo.break];
        const displayScore = (score * 2).toFixed(1);
        const remediation = breakCellData.remediation || {};
        
        let html = `
            <div class="focus-cell">
                <div class="cell-code ${info.category.toLowerCase()}">${currentDim}${breakInfo.break}</div>
                <div class="cell-info-text">
                    <div class="cell-name">${info.name}</div>
                    <div class="cell-layer">Layer ${breakInfo.break}: ${LAYERS[breakInfo.break]}</div>
                </div>
                <div class="cell-score weak">${displayScore}</div>
            </div>
        `;
        
        if (remediation.advice) {
            html += `<div class="modal-section"><h4>Recommendation</h4><div class="advice-box">${remediation.advice}</div></div>`;
        }
        
        if (remediation.scripture) {
            html += `
                <div class="modal-section">
                    <h4>Scripture</h4>
                    <div class="scripture-box">
                        <div class="scripture-text">"${remediation.scripture.text}"</div>
                        <div class="scripture-ref">— ${remediation.scripture.reference}</div>
                    </div>
                </div>
            `;
        }
        
        if (!remediation.advice && !remediation.scripture) {
            html += `<div class="modal-section"><p>Focus your energy on strengthening <strong>${LAYERS[breakInfo.break]}</strong> in your <strong>${info.name}</strong>. This is the foundation that must be solid before higher layers can hold weight.</p></div>`;
        }
        
        modalBody.innerHTML = html;
        modal.classList.remove('hidden');
    }
    
    function closeModal() { document.getElementById('whats-next-modal').classList.add('hidden'); }
    document.getElementById('whats-next-modal').addEventListener('click', (e) => { if (e.target.classList.contains('modal-overlay')) closeModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
    
    // Sidebar
    function getCategoryMin(data, category) {
        let min = 5;
        for (const dim of CATEGORIES[category]) for (let layer = 1; layer <= 8; layer++) if (data[dim][layer] < min) min = data[dim][layer];
        return min;
    }
    function getOverallScore(data) { return Math.min(getCategoryMin(data, 'Spirit'), getCategoryMin(data, 'Soul'), getCategoryMin(data, 'Body')); }
    function findDimBreakPoint(dimData) {
        let floor = 0, breakPoint = null;
        for (let layer = 1; layer <= 8; layer++) { if (dimData[layer] >= THRESHOLD) floor = layer; else if (breakPoint === null) breakPoint = layer; }
        if (breakPoint === null && floor > 0) return { floor: 8, break: null };
        if (floor === 0) return { floor: 0, break: 1 };
        return { floor, break: breakPoint };
    }
    
    function showCellInfo(dim, layer) {
        const info = DIMENSIONS[dim];
        const score = fullData[dim][layer];
        const displayScore = (score * 2).toFixed(1);
        const isStrong = score >= THRESHOLD;
        document.getElementById('hover-cell-name').textContent = `${dim}${layer}: ${info.name}`;
        document.getElementById('hover-cell-name').style.color = getCategoryColor(info.category);
        document.getElementById('hover-cell-detail').textContent = `Layer ${layer}: ${LAYERS[layer]} • ${info.category}`;
        document.getElementById('hover-cell-score').textContent = displayScore;
        const statusEl = document.getElementById('hover-cell-status');
        statusEl.textContent = isStrong ? `STRONG (≥${DISPLAY_THRESHOLD})` : `WEAK (<${DISPLAY_THRESHOLD})`;
        statusEl.className = 'cell-status ' + (isStrong ? 'strong' : 'weak');
    }
    
    function resetCellInfo() {
        document.getElementById('hover-cell-name').textContent = 'Hover over wheel';
        document.getElementById('hover-cell-name').style.color = '';
        document.getElementById('hover-cell-detail').textContent = '—';
        document.getElementById('hover-cell-score').textContent = '—';
        document.getElementById('hover-cell-status').textContent = '';
        document.getElementById('hover-cell-status').className = 'cell-status';
    }
    
    function highlightDimension(dim, breakLayerNum) {
        const svg = document.getElementById('wheel');
        svg.querySelectorAll('path[data-dim]').forEach(path => { path.style.opacity = path.getAttribute('data-dim') === dim ? '1' : '0.2'; });
        if (highlightMarker) { highlightMarker.remove(); highlightMarker = null; }
        if (breakLayerNum !== null && breakLayerNum > 0) {
            const dimIndex = DIM_ORDER.indexOf(dim);
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2, endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            const radius = MIN_RADIUS + (breakLayerNum - 1) * RING_WIDTH;
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            marker.setAttribute('d', describeArcLine(CX, CY, radius, startAngle, endAngle));
            marker.setAttribute('stroke', '#ffffff'); marker.setAttribute('stroke-width', '3');
            marker.setAttribute('fill', 'none'); marker.setAttribute('stroke-linecap', 'round');
            marker.style.filter = 'drop-shadow(0 0 4px rgba(255,255,255,0.8))';
            svg.appendChild(marker);
            highlightMarker = marker;
        }
    }
    
    function clearHighlight() {
        document.getElementById('wheel').querySelectorAll('path[data-dim]').forEach(path => { path.style.opacity = '1'; });
        if (highlightMarker) { highlightMarker.remove(); highlightMarker = null; }
    }
    
    function renderSidebar(data) {
        const container = document.getElementById('category-scores');
        container.innerHTML = '';
        ['Spirit', 'Soul', 'Body'].forEach(cat => {
            const min = getCategoryMin(data, cat);
            const displayMin = (min * 2).toFixed(1);
            const isStrong = min >= THRESHOLD;
            const row = document.createElement('div');
            row.className = 'category-row';
            row.innerHTML = `<span class="cat-name ${cat.toLowerCase()}">${cat}</span><span class="cat-score ${isStrong ? 'strong' : 'weak'}">${displayMin}</span>`;
            container.appendChild(row);
        });
        const overall = getOverallScore(data);
        const overallEl = document.getElementById('overall-score');
        overallEl.textContent = (overall * 2).toFixed(1);
        overallEl.className = 'score ' + (overall >= THRESHOLD ? 'strong' : 'weak');
        
        const breaksList = document.getElementById('breaks-list');
        breaksList.innerHTML = '';
        DIM_ORDER.forEach(dim => {
            const info = DIMENSIONS[dim];
            const { break: bp } = findDimBreakPoint(data[dim]);
            let layerText, layerClass;
            if (bp === null) { layerText = 'Solid'; layerClass = 'solid'; }
            else if (bp === 1) { layerText = 'L1 Crisis'; layerClass = 'crisis'; }
            else { layerText = `L${bp} ${LAYERS[bp]}`; layerClass = ''; }
            const item = document.createElement('div');
            item.className = 'break-item';
            item.innerHTML = `<span class="dim ${info.category.toLowerCase()}">${dim} ${info.name}</span><span class="layer ${layerClass}">${layerText}</span>`;
            item.addEventListener('mouseenter', () => highlightDimension(dim, bp));
            item.addEventListener('mouseleave', () => clearHighlight());
            breaksList.appendChild(item);
        });
    }
    
    // Wheel
    const CATEGORY_COLORS = { Spirit: { r: 128, g: 90, b: 213 }, Soul: { r: 49, g: 130, b: 206 }, Body: { r: 56, g: 161, b: 105 } };
    const CX = 0, CY = 0, MIN_RADIUS = 30, MAX_RADIUS = 220;
    const RING_WIDTH = (MAX_RADIUS - MIN_RADIUS) / 8, WEDGE_ANGLE = 360 / 9, GAP = 1;
    
    function scoreToColor(score, category) {
        const brightness = (score - 1) / 4;
        const c = CATEGORY_COLORS[category];
        return `rgb(${Math.round(c.r * brightness)}, ${Math.round(c.g * brightness)}, ${Math.round(c.b * brightness)})`;
    }
    function getCategoryColor(category) { return { Spirit: '#805ad5', Soul: '#3182ce', Body: '#38a169' }[category]; }
    function polarToCartesian(cx, cy, radius, angle) { const r = (angle - 90) * Math.PI / 180; return { x: cx + radius * Math.cos(r), y: cy + radius * Math.sin(r) }; }
    function describeArc(cx, cy, ir, or, sa, ea) {
        const s1 = polarToCartesian(cx, cy, or, ea), e1 = polarToCartesian(cx, cy, or, sa);
        const s2 = polarToCartesian(cx, cy, ir, sa), e2 = polarToCartesian(cx, cy, ir, ea);
        const laf = ea - sa <= 180 ? "0" : "1";
        return `M ${s1.x} ${s1.y} A ${or} ${or} 0 ${laf} 0 ${e1.x} ${e1.y} L ${s2.x} ${s2.y} A ${ir} ${ir} 0 ${laf} 1 ${e2.x} ${e2.y} Z`;
    }
    function describeArcLine(cx, cy, r, sa, ea) {
        const s = polarToCartesian(cx, cy, r, sa), e = polarToCartesian(cx, cy, r, ea);
        return `M ${s.x} ${s.y} A ${r} ${r} 0 ${ea - sa <= 180 ? "0" : "1"} 1 ${e.x} ${e.y}`;
    }
    function getEarliestBreak(data) {
        let earliest = null;
        for (const dim of DIM_ORDER) {
            let bp = null;
            for (let l = 1; l <= 8; l++) if (data[dim][l] < THRESHOLD && bp === null) bp = l;
            if (bp !== null && (earliest === null || bp < earliest)) earliest = bp;
        }
        return earliest;
    }
    function renderFace(svg, eb) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        let color, mouth;
        if (eb === null || eb >= 6) { color = '#68d391'; mouth = 'M -8 4 Q 0 12 8 4'; }
        else if (eb >= 3) { color = '#f6ad55'; mouth = 'M -8 6 L 8 6'; }
        else { color = '#fc8181'; mouth = 'M -8 10 Q 0 4 8 10'; }
        [[-6,-4], [6,-4]].forEach(([x,y]) => { const e = document.createElementNS('http://www.w3.org/2000/svg', 'circle'); e.setAttribute('cx', x); e.setAttribute('cy', y); e.setAttribute('r', 3); e.setAttribute('fill', color); g.appendChild(e); });
        const m = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        m.setAttribute('d', mouth); m.setAttribute('stroke', color); m.setAttribute('stroke-width', '2.5'); m.setAttribute('stroke-linecap', 'round'); m.setAttribute('fill', 'none');
        g.appendChild(m); svg.appendChild(g);
    }
    function renderWheel(data) {
        const svg = document.getElementById('wheel');
        svg.innerHTML = '';
        DIM_ORDER.forEach((dim, di) => {
            const sa = di * WEDGE_ANGLE + GAP/2, ea = (di + 1) * WEDGE_ANGLE - GAP/2;
            const cat = DIMENSIONS[dim].category;
            for (let l = 1; l <= 8; l++) {
                const ir = MIN_RADIUS + (l-1) * RING_WIDTH + 1, or = MIN_RADIUS + l * RING_WIDTH - 1;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', describeArc(CX, CY, ir, or, sa, ea));
                path.setAttribute('fill', scoreToColor(data[dim][l], cat));
                path.setAttribute('stroke', '#0d1117'); path.setAttribute('stroke-width', '1');
                path.setAttribute('data-dim', dim); path.setAttribute('data-layer', l);
                path.style.cursor = 'pointer'; path.style.transition = 'opacity 0.15s';
                path.addEventListener('mouseenter', () => { showCellInfo(dim, l); path.style.opacity = '0.8'; });
                path.addEventListener('mouseleave', () => { path.style.opacity = '1'; resetCellInfo(); });
                svg.appendChild(path);
            }
        });
        DIM_ORDER.forEach((dim, di) => {
            const pos = polarToCartesian(CX, CY, MAX_RADIUS + 20, (di + 0.5) * WEDGE_ANGLE);
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', pos.x); t.setAttribute('y', pos.y);
            t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
            t.setAttribute('fill', getCategoryColor(DIMENSIONS[dim].category));
            t.setAttribute('font-size', '12'); t.setAttribute('font-weight', 'bold');
            t.textContent = dim; svg.appendChild(t);
        });
        for (let l = 1; l <= 8; l++) {
            const pos = polarToCartesian(CX, CY, MIN_RADIUS + (l - 0.5) * RING_WIDTH, -10);
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', pos.x); t.setAttribute('y', pos.y);
            t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
            t.setAttribute('fill', '#6e7681'); t.setAttribute('font-size', '8');
            t.textContent = `L${l}`; svg.appendChild(t);
        }
        const cc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        cc.setAttribute('cx', CX); cc.setAttribute('cy', CY); cc.setAttribute('r', MIN_RADIUS - 2); cc.setAttribute('fill', '#0d1117');
        svg.appendChild(cc);
        renderFace(svg, getEarliestBreak(data));
    }
    
    function restart() {
        currentDim = null; scores = {}; fullProbes = new Set(); probeTrail = [];
        currentCell = null; breakLayer = null; fullData = null; highlightMarker = null; breakCellData = null;
        showPhase('select');
    }
    
    initDimensionSelect();
    </script>
</body>
</html>
