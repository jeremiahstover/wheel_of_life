<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic Assessment</title>
    <style>
        :root {
            --spirit: #805ad5;
            --soul: #3182ce;
            --body: #38a169;
            --bg: #0d1117;
            --card: #161b22;
            --text: #e2e8f0;
            --text-muted: #6e7681;
            --border: #30363d;
            --accent: #58a6ff;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: var(--text-muted);
            margin-bottom: 24px;
        }
        
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }
        
        .card h2, .card h3 {
            font-size: 1.1rem;
            margin-bottom: 16px;
            color: var(--text);
        }
        
        .card h3 {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        /* Phase: Dimension Selection */
        .dim-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        
        .dim-btn {
            padding: 16px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: transparent;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .dim-btn:hover {
            border-color: var(--accent);
            background: rgba(88, 166, 255, 0.1);
        }
        
        .dim-btn .code {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
        }
        
        .dim-btn .name {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .dim-btn.spirit .code { color: var(--spirit); }
        .dim-btn.soul .code { color: var(--soul); }
        .dim-btn.body .code { color: var(--body); }
        
        /* Phase: Questions */
        .progress-bar {
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
        }
        
        .cell-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }
        
        .cell-label {
            font-weight: bold;
        }
        
        .cell-layer {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .question-counter {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .probe-mode {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 8px;
            text-transform: uppercase;
        }
        
        .probe-mode.quick {
            background: rgba(88, 166, 255, 0.2);
            color: var(--accent);
        }
        
        .probe-mode.full {
            background: rgba(104, 211, 145, 0.2);
            color: #68d391;
        }
        
        .question-text {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .question-voice {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
            margin-bottom: 16px;
        }
        
        .answers {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .answer-btn {
            padding: 14px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: transparent;
            color: var(--text);
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .answer-btn:hover {
            border-color: var(--accent);
            background: rgba(88, 166, 255, 0.1);
        }
        
        .answer-btn .score-label {
            display: inline-block;
            width: 24px;
            font-weight: bold;
            color: var(--accent);
        }
        
        /* Phase: Processing */
        .processing {
            text-align: center;
            padding: 40px;
        }
        
        .processing .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Probe Trail */
        .probe-trail {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 16px;
        }
        
        .probe-item {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .probe-item.strong {
            background: rgba(104, 211, 145, 0.2);
            color: #68d391;
        }
        
        .probe-item.weak {
            background: rgba(252, 129, 129, 0.2);
            color: #fc8181;
        }
        
        .probe-item.current {
            background: rgba(88, 166, 255, 0.2);
            color: var(--accent);
        }
        
        /* Results */
        .results-layout {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 24px;
        }
        
        @media (max-width: 800px) {
            .results-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .result-summary {
            text-align: center;
            margin-bottom: 24px;
        }
        
        .result-summary h3 {
            font-size: 1.3rem;
            margin-bottom: 8px;
            text-transform: none;
            letter-spacing: normal;
        }
        
        .result-summary .break-info {
            font-size: 1.1rem;
            color: var(--text-muted);
        }
        
        .result-summary .break-info strong {
            color: #fc8181;
        }
        
        .result-summary .break-info.solid strong {
            color: #68d391;
        }
        
        .result-stats {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 12px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: var(--accent);
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }
        
        .btn-row {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
        }
        
        /* Wheel */
        .wheel-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #wheel {
            max-width: 100%;
            height: auto;
        }
        
        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .sidebar .card {
            margin-bottom: 0;
            padding: 16px;
        }
        
        /* Hover Info Card */
        .hover-info {
            min-height: 80px;
        }
        
        .hover-info .cell-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .hover-info .cell-detail {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 8px;
        }
        
        .hover-info .cell-score {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .hover-info .cell-status {
            font-size: 0.85rem;
            margin-top: 4px;
        }
        
        .hover-info .cell-status.strong { color: #68d391; }
        .hover-info .cell-status.weak { color: #fc8181; }
        
        .category-scores {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .category-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }
        
        .category-row .cat-name {
            font-weight: bold;
            font-size: 0.85rem;
        }
        
        .category-row .cat-name.spirit { color: var(--spirit); }
        .category-row .cat-name.soul { color: var(--soul); }
        .category-row .cat-name.body { color: var(--body); }
        
        .category-row .cat-score {
            font-weight: bold;
        }
        
        .category-row .cat-score.strong { color: #68d391; }
        .category-row .cat-score.weak { color: #fc8181; }
        
        .overall-row {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .overall-row .label {
            font-weight: bold;
            color: var(--text);
        }
        
        .overall-row .score {
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        .overall-row .score.strong { color: #68d391; }
        .overall-row .score.weak { color: #fc8181; }
        
        .breaks-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .break-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .break-item:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .break-item .dim {
            font-weight: bold;
        }
        
        .break-item .dim.spirit { color: var(--spirit); }
        .break-item .dim.soul { color: var(--soul); }
        .break-item .dim.body { color: var(--body); }
        
        .break-item .layer {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .break-item .layer.solid {
            color: #68d391;
        }
        
        .break-item .layer.crisis {
            color: #fc8181;
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-label {
            width: 50px;
            font-size: 0.75rem;
        }
        
        .legend-gradient {
            flex: 1;
            height: 12px;
            border-radius: 4px;
        }
        
        .legend-gradient.spirit {
            background: linear-gradient(to right, #000, #805ad5);
        }
        
        .legend-gradient.soul {
            background: linear-gradient(to right, #000, #3182ce);
        }
        
        .legend-gradient.body {
            background: linear-gradient(to right, #000, #38a169);
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
            margin-left: 58px;
        }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Diagnostic Assessment</h1>
        <p class="subtitle">Find your break points efficiently</p>
        
        <!-- Phase 1: Select Dimension -->
        <div id="phase-select" class="card">
            <h2>Choose a dimension to assess</h2>
            <div class="dim-grid" id="dim-grid"></div>
        </div>
        
        <!-- Phase 2: Answer Questions -->
        <div id="phase-questions" class="card hidden">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
            
            <div class="cell-info">
                <div>
                    <span class="cell-label" id="cell-label">A1</span>
                    <span class="cell-layer" id="cell-layer">Order</span>
                    <span class="probe-mode" id="probe-mode">quick</span>
                </div>
                <span class="question-counter" id="question-counter">Q1 of 2</span>
            </div>
            
            <div class="question-voice" id="question-voice"></div>
            <div class="question-text" id="question-text"></div>
            
            <div class="answers" id="answers"></div>
            
            <div class="probe-trail" id="probe-trail"></div>
        </div>
        
        <!-- Phase 3: Processing -->
        <div id="phase-processing" class="card hidden">
            <div class="processing">
                <div class="spinner"></div>
                <p>Analyzing results...</p>
            </div>
        </div>
        
        <!-- Phase 4: Results -->
        <div id="phase-results" class="hidden">
            <div class="results-layout">
                <div class="wheel-section">
                    <div class="card">
                        <div class="result-summary">
                            <h3 id="result-title">Assessment Complete</h3>
                            <p class="break-info" id="break-info"></p>
                            <p class="result-stats" id="result-stats"></p>
                        </div>
                        
                        <div class="wheel-container">
                            <svg id="wheel" viewBox="-260 -260 520 520" width="400" height="400"></svg>
                        </div>
                        
                        <div class="btn-row">
                            <button class="btn btn-secondary" onclick="restart()">Start Over</button>
                        </div>
                    </div>
                </div>
                
                <div class="sidebar">
                    <div class="card hover-info" id="hover-info">
                        <h3>Cell Details</h3>
                        <div class="cell-name" id="hover-cell-name">Hover over wheel</div>
                        <div class="cell-detail" id="hover-cell-detail">—</div>
                        <div class="cell-score" id="hover-cell-score">—</div>
                        <div class="cell-status" id="hover-cell-status"></div>
                    </div>
                    
                    <div class="card">
                        <h3>Limiting Factors</h3>
                        <div class="category-scores" id="category-scores"></div>
                        <div class="overall-row">
                            <span class="label">Overall</span>
                            <span class="score" id="overall-score">—</span>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Break Points</h3>
                        <div class="breaks-list" id="breaks-list"></div>
                    </div>
                    
                    <div class="card">
                        <h3>Legend</h3>
                        <div class="legend">
                            <div class="legend-row">
                                <span class="legend-label" style="color: var(--spirit)">Spirit</span>
                                <div class="legend-gradient spirit"></div>
                            </div>
                            <div class="legend-row">
                                <span class="legend-label" style="color: var(--soul)">Soul</span>
                                <div class="legend-gradient soul"></div>
                            </div>
                            <div class="legend-row">
                                <span class="legend-label" style="color: var(--body)">Body</span>
                                <div class="legend-gradient body"></div>
                            </div>
                        </div>
                        <div class="legend-labels">
                            <span>2 (Crisis)</span>
                            <span>10 (Exceptional)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    
    const DIMENSIONS = {
        A: { name: 'Communion', category: 'Spirit' },
        B: { name: 'Conscience', category: 'Spirit' },
        C: { name: 'Holiness', category: 'Spirit' },
        D: { name: 'Mind', category: 'Soul' },
        E: { name: 'Will', category: 'Soul' },
        F: { name: 'Emotions', category: 'Soul' },
        G: { name: 'Sustenance', category: 'Body' },
        H: { name: 'Capability', category: 'Body' },
        I: { name: 'Wholeness', category: 'Body' },
    };
    
    const LAYERS = {
        1: 'Order',
        2: 'Causality', 
        3: 'Responsibility',
        4: 'Discipline',
        5: 'Skill',
        6: 'Resources',
        7: 'Fellowship',
        8: 'Sacrifice'
    };
    
    const CATEGORIES = {
        Spirit: ['A', 'B', 'C'],
        Soul: ['D', 'E', 'F'],
        Body: ['G', 'H', 'I']
    };
    
    // Fallback Likert scale if answers not provided
    const LIKERT_SCALE = {
        1: 'Strongly Disagree',
        2: 'Disagree',
        3: 'Neutral / Unsure',
        4: 'Agree',
        5: 'Strongly Agree'
    };
    
    const DIM_ORDER = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    const THRESHOLD = 3.5;
    const DISPLAY_THRESHOLD = 7;
    const DATA_PATH = '/data/questions/';
    
    // Quick probe settings
    const QUICK_PROBE_COUNT = 2;
    const QUICK_PROBE_TIEBREAK = 1;
    const STRONG_THRESHOLD = 4;
    const WEAK_THRESHOLD = 2;
    
    // ============================================
    // STATE
    // ============================================
    
    let currentDim = null;
    let scores = {};
    let fullProbes = new Set();
    let probeTrail = [];
    let currentCell = null;
    let currentQuestionIdx = 0;
    let currentAnswers = [];
    let questionsAnswered = 0;
    let breakLayer = null;
    let fullData = null;          // Store wheel data for hover
    let highlightMarker = null;   // For break point arc marker
    
    let searchState = {
        phase: 'initial',
        probeQueue: [],
    };
    
    // ============================================
    // PHASE MANAGEMENT
    // ============================================
    
    function showPhase(phase) {
        document.querySelectorAll('#phase-select, #phase-questions, #phase-processing, #phase-results')
            .forEach(el => el.classList.add('hidden'));
        document.getElementById(`phase-${phase}`).classList.remove('hidden');
    }
    
    // ============================================
    // PHASE 1: DIMENSION SELECTION
    // ============================================
    
    function initDimensionSelect() {
        const grid = document.getElementById('dim-grid');
        grid.innerHTML = '';
        
        DIM_ORDER.forEach(code => {
            const info = DIMENSIONS[code];
            const btn = document.createElement('button');
            btn.className = `dim-btn ${info.category.toLowerCase()}`;
            btn.innerHTML = `
                <span class="code">${code}</span>
                <span class="name">${info.name}</span>
            `;
            btn.onclick = () => selectDimension(code);
            grid.appendChild(btn);
        });
    }
    
    function selectDimension(dim) {
        currentDim = dim;
        scores = {};
        fullProbes = new Set();
        probeTrail = [];
        questionsAnswered = 0;
        breakLayer = null;
        
        searchState = {
            phase: 'initial',
            probeQueue: [3, 6],
        };
        
        showPhase('questions');
        probeNextLayer();
    }
    
    // ============================================
    // PHASE 2: BINARY SEARCH & QUESTIONS
    // ============================================
    
    async function probeNextLayer() {
        const nextLayer = determineNextProbe();
        
        if (nextLayer === null) {
            if (breakLayer !== null && !fullProbes.has(breakLayer)) {
                await loadCell(currentDim, breakLayer, true);
                return;
            }
            finishAssessment();
            return;
        }
        
        await loadCell(currentDim, nextLayer, false);
    }
    
    function determineNextProbe() {
        if (searchState.phase === 'initial') {
            if (searchState.probeQueue.length > 0) {
                return searchState.probeQueue.shift();
            }
            searchState.phase = 'narrowing';
            return determineNextProbe();
        }
        
        if (searchState.phase === 'narrowing') {
            const l3Strong = scores[3] >= THRESHOLD;
            const l6Strong = scores[6] >= THRESHOLD;
            
            if (l3Strong && l6Strong) {
                if (scores[7] === undefined) return 7;
                if (scores[8] === undefined) return 8;
                breakLayer = null;
            } else if (!l3Strong && !l6Strong) {
                if (scores[2] === undefined) return 2;
                if (scores[1] === undefined) return 1;
                if (scores[1] >= THRESHOLD) breakLayer = 2;
                else if (scores[2] >= THRESHOLD) breakLayer = 3;
                else breakLayer = 1;
            } else if (l3Strong && !l6Strong) {
                if (scores[4] === undefined) return 4;
                if (scores[5] === undefined) return 5;
                if (scores[4] >= THRESHOLD && scores[5] >= THRESHOLD) breakLayer = 6;
                else if (scores[4] >= THRESHOLD) breakLayer = 5;
                else breakLayer = 4;
            } else {
                if (scores[2] === undefined) return 2;
                if (scores[1] === undefined) return 1;
                if (scores[4] === undefined) return 4;
                if (scores[5] === undefined) return 5;
                for (let l = 1; l <= 8; l++) {
                    if (scores[l] !== undefined && scores[l] < THRESHOLD) {
                        breakLayer = l;
                        break;
                    }
                }
            }
            
            searchState.phase = 'confirming';
            return determineNextProbe();
        }
        
        if (searchState.phase === 'confirming') {
            if (breakLayer !== null && breakLayer > 1) {
                const floorLayer = breakLayer - 1;
                if (scores[floorLayer] === undefined) return floorLayer;
            }
        }
        
        return null;
    }
    
    async function loadCell(dim, layer, isFullProbe) {
        const url = `${DATA_PATH}${dim}${layer}.json`;
        
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load ${url}`);
            
            const cellData = await response.json();
            currentCell = {
                dim,
                layer,
                questions: cellData.questions,
                layerName: LAYERS[layer],
                isFullProbe,
            };
            currentQuestionIdx = 0;
            currentAnswers = [];
            
            displayQuestion();
            updateProbeTrail();
        } catch (error) {
            console.error('Error loading cell:', error);
            recordCellScore(layer, 3.0, isFullProbe);
            probeNextLayer();
        }
    }
    
    function getQuestionsToAsk() {
        if (currentCell.isFullProbe) {
            return currentCell.questions.length;
        }
        
        if (currentAnswers.length < QUICK_PROBE_COUNT) {
            return QUICK_PROBE_COUNT;
        }
        
        const allStrong = currentAnswers.every(a => a >= STRONG_THRESHOLD);
        const allWeak = currentAnswers.every(a => a <= WEAK_THRESHOLD);
        
        if (allStrong || allWeak) {
            return QUICK_PROBE_COUNT;
        }
        
        return QUICK_PROBE_COUNT + QUICK_PROBE_TIEBREAK;
    }
    
    function displayQuestion() {
        const q = currentCell.questions[currentQuestionIdx];
        const questionsToAsk = getQuestionsToAsk();
        
        document.getElementById('cell-label').textContent = 
            `${currentCell.dim}${currentCell.layer}: ${DIMENSIONS[currentCell.dim].name}`;
        document.getElementById('cell-layer').textContent = 
            `Layer ${currentCell.layer}: ${currentCell.layerName}`;
        
        const modeEl = document.getElementById('probe-mode');
        modeEl.textContent = currentCell.isFullProbe ? 'full' : 'quick';
        modeEl.className = `probe-mode ${currentCell.isFullProbe ? 'full' : 'quick'}`;
        
        document.getElementById('question-counter').textContent = 
            `Q${currentQuestionIdx + 1} of ${questionsToAsk}`;
        
        document.getElementById('question-voice').textContent = 
            q.voice ? `Voice: ${q.voice}` : '';
        document.getElementById('question-text').textContent = q.text;
        
        const answersEl = document.getElementById('answers');
        answersEl.innerHTML = '';
        
        const hasCustomAnswers = q.answers && typeof q.answers === 'object';
        
        for (let i = 1; i <= 5; i++) {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            
            const answerText = hasCustomAnswers 
                ? (q.answers[i] || q.answers[String(i)] || LIKERT_SCALE[i])
                : LIKERT_SCALE[i];
            
            btn.innerHTML = `<span class="score-label">${i}.</span> ${answerText}`;
            btn.onclick = () => selectAnswer(i);
            answersEl.appendChild(btn);
        }
        
        const totalEstimated = 15;
        const progress = Math.min(100, (questionsAnswered / totalEstimated) * 100);
        document.getElementById('progress-fill').style.width = `${progress}%`;
    }
    
    function selectAnswer(score) {
        currentAnswers.push(score);
        questionsAnswered++;
        currentQuestionIdx++;
        
        const questionsToAsk = getQuestionsToAsk();
        
        if (currentQuestionIdx < questionsToAsk && currentQuestionIdx < currentCell.questions.length) {
            displayQuestion();
        } else {
            const avg = currentAnswers.reduce((a, b) => a + b, 0) / currentAnswers.length;
            recordCellScore(currentCell.layer, avg, currentCell.isFullProbe);
            probeNextLayer();
        }
    }
    
    function recordCellScore(layer, score, isFullProbe) {
        scores[layer] = score;
        
        if (isFullProbe) {
            fullProbes.add(layer);
        }
        
        probeTrail.push({
            layer,
            score,
            status: score >= THRESHOLD ? 'strong' : 'weak',
            mode: isFullProbe ? 'full' : 'quick'
        });
    }
    
    function updateProbeTrail() {
        const trailEl = document.getElementById('probe-trail');
        trailEl.innerHTML = '';
        
        probeTrail.forEach(p => {
            const item = document.createElement('span');
            item.className = `probe-item ${p.status}`;
            item.textContent = `L${p.layer}: ${(p.score * 2).toFixed(1)}`;
            if (p.mode === 'full') item.textContent += '★';
            trailEl.appendChild(item);
        });
        
        if (currentCell) {
            const current = document.createElement('span');
            current.className = 'probe-item current';
            current.textContent = `L${currentCell.layer}...`;
            trailEl.appendChild(current);
        }
    }
    
    function findBreakPoint() {
        let floor = 0;
        let bp = null;
        
        for (let layer = 1; layer <= 8; layer++) {
            if (scores[layer] !== undefined) {
                if (scores[layer] >= THRESHOLD) {
                    floor = layer;
                } else if (bp === null) {
                    bp = layer;
                }
            }
        }
        
        if (bp === null && floor < 8) {
            for (let layer = floor + 1; layer <= 8; layer++) {
                if (scores[layer] !== undefined && scores[layer] < THRESHOLD) {
                    bp = layer;
                    break;
                }
            }
        }
        
        if (bp === null && floor > 0) {
            return { floor: 8, break: null };
        }
        
        if (floor === 0 && (scores[1] === undefined || scores[1] < THRESHOLD)) {
            return { floor: 0, break: 1 };
        }
        
        return { floor, break: bp };
    }
    
    // ============================================
    // PHASE 3 & 4: RESULTS
    // ============================================
    
    function finishAssessment() {
        showPhase('processing');
        
        fillMissingLayers();
        
        setTimeout(() => {
            showPhase('results');
            displayResults();
        }, 800);
    }
    
    function fillMissingLayers() {
        for (let layer = 1; layer <= 8; layer++) {
            if (scores[layer] === undefined) {
                let below = null, above = null;
                for (let l = layer - 1; l >= 1; l--) {
                    if (scores[l] !== undefined) { below = scores[l]; break; }
                }
                for (let l = layer + 1; l <= 8; l++) {
                    if (scores[l] !== undefined) { above = scores[l]; break; }
                }
                
                if (below !== null && above !== null) {
                    scores[layer] = (below + above) / 2;
                } else if (below !== null) {
                    scores[layer] = below * 0.9;
                } else if (above !== null) {
                    scores[layer] = Math.min(5, above * 1.1);
                } else {
                    scores[layer] = 3.0;
                }
            }
        }
    }
    
    function displayResults() {
        const breakInfo = findBreakPoint();
        
        const titleEl = document.getElementById('result-title');
        const infoEl = document.getElementById('break-info');
        const statsEl = document.getElementById('result-stats');
        
        if (breakInfo.break === null) {
            titleEl.textContent = `${currentDim}: ${DIMENSIONS[currentDim].name} — Solid`;
            infoEl.className = 'break-info solid';
            infoEl.innerHTML = `<strong>No break point</strong> — strong through all layers`;
        } else {
            titleEl.textContent = `${currentDim}: ${DIMENSIONS[currentDim].name}`;
            infoEl.className = 'break-info';
            infoEl.innerHTML = `Break at <strong>L${breakInfo.break} ${LAYERS[breakInfo.break]}</strong> — focus here`;
        }
        
        statsEl.textContent = `${questionsAnswered} questions answered`;
        
        // Build full data (mirror to all dimensions)
        fullData = {};
        DIM_ORDER.forEach(dim => {
            fullData[dim] = {};
            for (let layer = 1; layer <= 8; layer++) {
                fullData[dim][layer] = scores[layer];
            }
        });
        
        renderWheel(fullData);
        renderSidebar(fullData);
    }
    
    // ============================================
    // SIDEBAR RENDERING
    // ============================================
    
    function getCategoryMin(data, category) {
        let min = 5;
        for (const dim of CATEGORIES[category]) {
            for (let layer = 1; layer <= 8; layer++) {
                if (data[dim][layer] < min) {
                    min = data[dim][layer];
                }
            }
        }
        return min;
    }
    
    function getOverallScore(data) {
        const spiritMin = getCategoryMin(data, 'Spirit');
        const soulMin = getCategoryMin(data, 'Soul');
        const bodyMin = getCategoryMin(data, 'Body');
        return Math.min(spiritMin, soulMin, bodyMin);
    }
    
    function findDimBreakPoint(dimData) {
        let floor = 0;
        let breakPoint = null;
        
        for (let layer = 1; layer <= 8; layer++) {
            if (dimData[layer] >= THRESHOLD) {
                floor = layer;
            } else {
                if (breakPoint === null) {
                    breakPoint = layer;
                }
            }
        }
        
        if (breakPoint === null && floor > 0) {
            return { floor: 8, break: null };
        }
        if (floor === 0) {
            return { floor: 0, break: 1 };
        }
        return { floor, break: breakPoint };
    }
    
    function showCellInfo(dim, layer) {
        const info = DIMENSIONS[dim];
        const score = fullData[dim][layer];
        const displayScore = score * 2;
        const isStrong = score >= THRESHOLD;
        
        document.getElementById('hover-cell-name').textContent = `${dim}${layer}: ${info.name}`;
        document.getElementById('hover-cell-name').style.color = getCategoryColor(info.category);
        document.getElementById('hover-cell-detail').textContent = `Layer ${layer}: ${LAYERS[layer]} • ${info.category}`;
        document.getElementById('hover-cell-score').textContent = displayScore.toFixed(1);
        
        const statusEl = document.getElementById('hover-cell-status');
        statusEl.textContent = isStrong ? `STRONG (≥${DISPLAY_THRESHOLD})` : `WEAK (<${DISPLAY_THRESHOLD})`;
        statusEl.className = 'cell-status ' + (isStrong ? 'strong' : 'weak');
    }
    
    function resetCellInfo() {
        document.getElementById('hover-cell-name').textContent = 'Hover over wheel';
        document.getElementById('hover-cell-name').style.color = '';
        document.getElementById('hover-cell-detail').textContent = '—';
        document.getElementById('hover-cell-score').textContent = '—';
        document.getElementById('hover-cell-status').textContent = '';
        document.getElementById('hover-cell-status').className = 'cell-status';
    }
    
    function highlightDimension(dim, breakLayerNum) {
        const svg = document.getElementById('wheel');
        
        // Dim all cells except the highlighted dimension
        svg.querySelectorAll('path[data-dim]').forEach(path => {
            if (path.getAttribute('data-dim') === dim) {
                path.style.opacity = '1';
            } else {
                path.style.opacity = '0.2';
            }
        });
        
        // Remove old marker
        if (highlightMarker) {
            highlightMarker.remove();
            highlightMarker = null;
        }
        
        // Draw white arc at break point
        if (breakLayerNum !== null && breakLayerNum > 0) {
            const dimIndex = DIM_ORDER.indexOf(dim);
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2;
            const endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            
            const radius = MIN_RADIUS + (breakLayerNum - 1) * RING_WIDTH;
            
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            marker.setAttribute('d', describeArcLine(CX, CY, radius, startAngle, endAngle));
            marker.setAttribute('stroke', '#ffffff');
            marker.setAttribute('stroke-width', '3');
            marker.setAttribute('fill', 'none');
            marker.setAttribute('stroke-linecap', 'round');
            marker.style.filter = 'drop-shadow(0 0 4px rgba(255,255,255,0.8))';
            
            svg.appendChild(marker);
            highlightMarker = marker;
        }
    }
    
    function clearHighlight() {
        const svg = document.getElementById('wheel');
        
        svg.querySelectorAll('path[data-dim]').forEach(path => {
            path.style.opacity = '1';
        });
        
        if (highlightMarker) {
            highlightMarker.remove();
            highlightMarker = null;
        }
    }
    
    function renderSidebar(data) {
        // Category scores
        const container = document.getElementById('category-scores');
        container.innerHTML = '';
        
        ['Spirit', 'Soul', 'Body'].forEach(cat => {
            const min = getCategoryMin(data, cat);
            const displayMin = min * 2;
            const isStrong = min >= THRESHOLD;
            
            const row = document.createElement('div');
            row.className = 'category-row';
            row.innerHTML = `
                <span class="cat-name ${cat.toLowerCase()}">${cat}</span>
                <span class="cat-score ${isStrong ? 'strong' : 'weak'}">${displayMin.toFixed(1)}</span>
            `;
            container.appendChild(row);
        });
        
        // Overall
        const overall = getOverallScore(data);
        const displayOverall = overall * 2;
        const overallEl = document.getElementById('overall-score');
        overallEl.textContent = displayOverall.toFixed(1);
        overallEl.className = 'score ' + (overall >= THRESHOLD ? 'strong' : 'weak');
        
        // Break points list
        const breaksList = document.getElementById('breaks-list');
        breaksList.innerHTML = '';
        
        DIM_ORDER.forEach(dim => {
            const info = DIMENSIONS[dim];
            const { break: bp } = findDimBreakPoint(data[dim]);
            
            let layerText, layerClass;
            if (bp === null) {
                layerText = 'Solid';
                layerClass = 'solid';
            } else if (bp === 1) {
                layerText = 'L1 Crisis';
                layerClass = 'crisis';
            } else {
                layerText = `L${bp} ${LAYERS[bp]}`;
                layerClass = '';
            }
            
            const item = document.createElement('div');
            item.className = 'break-item';
            item.innerHTML = `
                <span class="dim ${info.category.toLowerCase()}">${dim} ${info.name}</span>
                <span class="layer ${layerClass}">${layerText}</span>
            `;
            
            // Hover events for highlighting
            item.addEventListener('mouseenter', () => {
                highlightDimension(dim, bp);
            });
            item.addEventListener('mouseleave', () => {
                clearHighlight();
            });
            
            breaksList.appendChild(item);
        });
    }
    
    // ============================================
    // WHEEL RENDERING
    // ============================================
    
    const CATEGORY_COLORS = {
        Spirit: { r: 128, g: 90, b: 213 },
        Soul:   { r: 49, g: 130, b: 206 },
        Body:   { r: 56, g: 161, b: 105 },
    };
    
    const CX = 0, CY = 0;
    const MIN_RADIUS = 30;
    const MAX_RADIUS = 220;
    const RING_WIDTH = (MAX_RADIUS - MIN_RADIUS) / 8;
    const WEDGE_ANGLE = 360 / 9;
    const GAP = 1;
    
    function scoreToColor(score, category) {
        const brightness = (score - 1) / 4;
        const baseColor = CATEGORY_COLORS[category];
        const r = Math.round(baseColor.r * brightness);
        const g = Math.round(baseColor.g * brightness);
        const b = Math.round(baseColor.b * brightness);
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    function getCategoryColor(category) {
        switch(category) {
            case 'Spirit': return '#805ad5';
            case 'Soul': return '#3182ce';
            case 'Body': return '#38a169';
        }
    }
    
    function polarToCartesian(cx, cy, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
            x: cx + (radius * Math.cos(angleInRadians)),
            y: cy + (radius * Math.sin(angleInRadians))
        };
    }
    
    function describeArc(cx, cy, innerRadius, outerRadius, startAngle, endAngle) {
        const start1 = polarToCartesian(cx, cy, outerRadius, endAngle);
        const end1 = polarToCartesian(cx, cy, outerRadius, startAngle);
        const start2 = polarToCartesian(cx, cy, innerRadius, startAngle);
        const end2 = polarToCartesian(cx, cy, innerRadius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        return [
            "M", start1.x, start1.y,
            "A", outerRadius, outerRadius, 0, largeArcFlag, 0, end1.x, end1.y,
            "L", start2.x, start2.y,
            "A", innerRadius, innerRadius, 0, largeArcFlag, 1, end2.x, end2.y,
            "Z"
        ].join(" ");
    }
    
    function describeArcLine(cx, cy, radius, startAngle, endAngle) {
        const start = polarToCartesian(cx, cy, radius, startAngle);
        const end = polarToCartesian(cx, cy, radius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        
        return [
            "M", start.x, start.y,
            "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y
        ].join(" ");
    }
    
    function getEarliestBreak(data) {
        let earliest = null;
        for (const dim of DIM_ORDER) {
            let bp = null;
            for (let layer = 1; layer <= 8; layer++) {
                if (data[dim][layer] < THRESHOLD && bp === null) {
                    bp = layer;
                }
            }
            if (bp !== null && (earliest === null || bp < earliest)) {
                earliest = bp;
            }
        }
        return earliest;
    }
    
    function renderFace(svg, earliestBreak) {
        const faceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        
        let faceColor, mouthPath;
        if (earliestBreak === null || earliestBreak >= 6) {
            faceColor = '#68d391';
            mouthPath = 'M -8 4 Q 0 12 8 4';
        } else if (earliestBreak >= 3) {
            faceColor = '#f6ad55';
            mouthPath = 'M -8 6 L 8 6';
        } else {
            faceColor = '#fc8181';
            mouthPath = 'M -8 10 Q 0 4 8 10';
        }
        
        const leftEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        leftEye.setAttribute('cx', -6);
        leftEye.setAttribute('cy', -4);
        leftEye.setAttribute('r', 3);
        leftEye.setAttribute('fill', faceColor);
        faceGroup.appendChild(leftEye);
        
        const rightEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        rightEye.setAttribute('cx', 6);
        rightEye.setAttribute('cy', -4);
        rightEye.setAttribute('r', 3);
        rightEye.setAttribute('fill', faceColor);
        faceGroup.appendChild(rightEye);
        
        const mouth = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        mouth.setAttribute('d', mouthPath);
        mouth.setAttribute('stroke', faceColor);
        mouth.setAttribute('stroke-width', '2.5');
        mouth.setAttribute('stroke-linecap', 'round');
        mouth.setAttribute('fill', 'none');
        faceGroup.appendChild(mouth);
        
        svg.appendChild(faceGroup);
    }
    
    function renderWheel(data) {
        const svg = document.getElementById('wheel');
        svg.innerHTML = '';
        
        // Draw cells
        DIM_ORDER.forEach((dim, dimIndex) => {
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2;
            const endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            const category = DIMENSIONS[dim].category;
            
            for (let layer = 1; layer <= 8; layer++) {
                const innerRadius = MIN_RADIUS + (layer - 1) * RING_WIDTH + 1;
                const outerRadius = MIN_RADIUS + layer * RING_WIDTH - 1;
                const score = data[dim][layer];
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', describeArc(CX, CY, innerRadius, outerRadius, startAngle, endAngle));
                path.setAttribute('fill', scoreToColor(score, category));
                path.setAttribute('stroke', '#0d1117');
                path.setAttribute('stroke-width', '1');
                path.setAttribute('data-dim', dim);
                path.setAttribute('data-layer', layer);
                path.style.cursor = 'pointer';
                path.style.transition = 'opacity 0.15s';
                
                // Hover events for cell info
                path.addEventListener('mouseenter', () => {
                    showCellInfo(dim, layer);
                    path.style.opacity = '0.8';
                });
                path.addEventListener('mouseleave', () => {
                    path.style.opacity = '1';
                    resetCellInfo();
                });
                
                svg.appendChild(path);
            }
        });
        
        // Dimension labels
        DIM_ORDER.forEach((dim, dimIndex) => {
            const angle = (dimIndex + 0.5) * WEDGE_ANGLE;
            const pos = polarToCartesian(CX, CY, MAX_RADIUS + 20, angle);
            const info = DIMENSIONS[dim];
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', getCategoryColor(info.category));
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.textContent = dim;
            svg.appendChild(text);
        });
        
        // Layer labels
        for (let layer = 1; layer <= 8; layer++) {
            const radius = MIN_RADIUS + (layer - 0.5) * RING_WIDTH;
            const pos = polarToCartesian(CX, CY, radius, -10);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#6e7681');
            text.setAttribute('font-size', '8');
            text.textContent = `L${layer}`;
            svg.appendChild(text);
        }
        
        // Center circle
        const centerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        centerCircle.setAttribute('cx', CX);
        centerCircle.setAttribute('cy', CY);
        centerCircle.setAttribute('r', MIN_RADIUS - 2);
        centerCircle.setAttribute('fill', '#0d1117');
        svg.appendChild(centerCircle);
        
        // Face
        const earliestBreak = getEarliestBreak(data);
        renderFace(svg, earliestBreak);
    }
    
    // ============================================
    // RESTART
    // ============================================
    
    function restart() {
        currentDim = null;
        scores = {};
        fullProbes = new Set();
        probeTrail = [];
        currentCell = null;
        breakLayer = null;
        fullData = null;
        highlightMarker = null;
        showPhase('select');
    }
    
    // ============================================
    // INIT
    // ============================================
    
    initDimensionSelect();
    </script>
</body>
</html>
