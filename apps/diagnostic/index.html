<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagnostic Assessment</title>
    <style>
        :root {
            --spirit: #805ad5;
            --soul: #3182ce;
            --body: #38a169;
            --bg: #0d1117;
            --card: #161b22;
            --text: #e2e8f0;
            --text-muted: #6e7681;
            --border: #30363d;
            --accent: #58a6ff;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { max-width: 900px; margin: 0 auto; }
        h1 { font-size: 1.5rem; margin-bottom: 8px; }
        .subtitle { color: var(--text-muted); margin-bottom: 24px; }
        
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }
        .card h2, .card h3 { font-size: 1.1rem; margin-bottom: 16px; color: var(--text); }
        .card h3 { font-size: 0.8rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px; }
        
        /* Mode Selection */
        .mode-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px; }
        @media (max-width: 600px) { .mode-grid { grid-template-columns: 1fr; } }
        .mode-btn { padding: 24px; border: 2px solid var(--border); border-radius: 12px; background: transparent; color: var(--text); cursor: pointer; transition: all 0.2s; text-align: left; }
        .mode-btn:hover { border-color: var(--accent); background: rgba(88, 166, 255, 0.1); }
        .mode-btn h3 { margin-bottom: 8px; font-size: 1.1rem; color: var(--text); text-transform: none; letter-spacing: normal; }
        .mode-btn p { color: var(--text-muted); font-size: 0.9rem; line-height: 1.4; margin: 0; }
        .mode-btn .estimate { margin-top: 12px; font-size: 0.8rem; color: var(--accent); }
        
        .dim-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
        .dim-btn { padding: 16px; border: 2px solid var(--border); border-radius: 8px; background: transparent; color: var(--text); cursor: pointer; transition: all 0.2s; text-align: center; position: relative; }
        .dim-btn:hover { border-color: var(--accent); background: rgba(88, 166, 255, 0.1); }
        .dim-btn.completed { border-color: #68d391; background: rgba(104, 211, 145, 0.1); cursor: default; }
        .dim-btn.completed::after { content: '✓'; position: absolute; top: 8px; right: 8px; color: #68d391; font-weight: bold; }
        .dim-btn .code { font-size: 1.5rem; font-weight: bold; display: block; }
        .dim-btn .name { font-size: 0.85rem; color: var(--text-muted); }
        .dim-btn.spirit .code { color: var(--spirit); }
        .dim-btn.soul .code { color: var(--soul); }
        .dim-btn.body .code { color: var(--body); }
        
        .resume-section { margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border); }
        .resume-info { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 12px; }
        
        .progress-bar { height: 4px; background: var(--border); border-radius: 2px; margin-bottom: 20px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); transition: width 0.3s; }
        .cell-info { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border); }
        .cell-label { font-weight: bold; }
        .cell-layer { color: var(--text-muted); font-size: 0.9rem; }
        .question-counter { color: var(--text-muted); font-size: 0.85rem; }
        .confidence-indicator { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; margin-left: 8px; text-transform: uppercase; background: rgba(88, 166, 255, 0.2); color: var(--accent); }
        .question-text { font-size: 1.1rem; line-height: 1.6; margin-bottom: 20px; }
        .question-voice { color: var(--text-muted); font-size: 0.8rem; font-style: italic; margin-bottom: 16px; }
        .answers { display: flex; flex-direction: column; gap: 10px; }
        .answer-btn { padding: 14px 16px; border: 1px solid var(--border); border-radius: 8px; background: transparent; color: var(--text); cursor: pointer; text-align: left; transition: all 0.2s; font-size: 0.95rem; line-height: 1.4; }
        .answer-btn:hover { border-color: var(--accent); background: rgba(88, 166, 255, 0.1); }
        .answer-btn .score-label { display: inline-block; width: 24px; font-weight: bold; color: var(--accent); }
        
        .processing { text-align: center; padding: 40px; }
        .processing .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .progress-summary { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 16px; }
        .progress-pip { width: 8px; height: 8px; border-radius: 2px; background: var(--border); }
        .progress-pip.complete { background: #68d391; }
        .progress-pip.active { background: var(--accent); }
        
        .results-layout { display: grid; grid-template-columns: 1fr 280px; gap: 24px; }
        @media (max-width: 800px) { .results-layout { grid-template-columns: 1fr; } }
        .result-summary { text-align: center; margin-bottom: 24px; }
        .result-summary h3 { font-size: 1.3rem; margin-bottom: 8px; text-transform: none; letter-spacing: normal; }
        .result-summary .break-info { font-size: 1.1rem; color: var(--text-muted); }
        .result-summary .break-info strong { color: #fc8181; }
        .result-summary .break-info.solid strong { color: #68d391; }
        .result-stats { font-size: 0.85rem; color: var(--text-muted); margin-top: 12px; }
        
        .btn { padding: 12px 24px; border: none; border-radius: 8px; background: var(--accent); color: #fff; font-size: 1rem; cursor: pointer; transition: opacity 0.2s; }
        .btn:hover { opacity: 0.9; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-primary { background: #68d391; color: #0d1117; font-weight: bold; }
        .btn-small { padding: 8px 16px; font-size: 0.85rem; }
        .btn-row { display: flex; gap: 12px; justify-content: center; margin-top: 20px; flex-wrap: wrap; }
        
        .wheel-container { display: flex; justify-content: center; align-items: center; }
        #wheel { max-width: 100%; height: auto; }
        
        .sidebar { display: flex; flex-direction: column; gap: 16px; }
        .sidebar .card { margin-bottom: 0; padding: 16px; }
        
        .hover-info { min-height: 80px; }
        .hover-info .cell-name { font-size: 1.2rem; font-weight: bold; margin-bottom: 4px; }
        .hover-info .cell-detail { color: var(--text-muted); font-size: 0.85rem; margin-bottom: 8px; }
        .hover-info .cell-score { font-size: 1.5rem; font-weight: bold; }
        .hover-info .cell-status { font-size: 0.85rem; margin-top: 4px; }
        .hover-info .cell-status.strong { color: #68d391; }
        .hover-info .cell-status.weak { color: #fc8181; }
        .hover-info .cell-status.pending { color: var(--text-muted); }
        
        .category-scores { display: flex; flex-direction: column; gap: 8px; }
        .category-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; background: rgba(0,0,0,0.3); border-radius: 6px; }
        .category-row .cat-name { font-weight: bold; font-size: 0.85rem; }
        .category-row .cat-name.spirit { color: var(--spirit); }
        .category-row .cat-name.soul { color: var(--soul); }
        .category-row .cat-name.body { color: var(--body); }
        .category-row .cat-score { font-weight: bold; }
        .category-row .cat-score.strong { color: #68d391; }
        .category-row .cat-score.weak { color: #fc8181; }
        .category-row .cat-score.pending { color: var(--text-muted); }
        
        .overall-row { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .overall-row .label { font-weight: bold; color: var(--text); }
        .overall-row .score { font-size: 1.2rem; font-weight: bold; }
        .overall-row .score.strong { color: #68d391; }
        .overall-row .score.weak { color: #fc8181; }
        .overall-row .score.pending { color: var(--text-muted); }
        
        .breaks-list { display: flex; flex-direction: column; gap: 8px; }
        .break-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px; cursor: pointer; transition: background 0.15s; }
        .break-item:hover { background: rgba(255,255,255,0.1); }
        .break-item .dim { font-weight: bold; }
        .break-item .dim.spirit { color: var(--spirit); }
        .break-item .dim.soul { color: var(--soul); }
        .break-item .dim.body { color: var(--body); }
        .break-item .layer { color: var(--text-muted); font-size: 0.85rem; }
        .break-item .layer.solid { color: #68d391; }
        .break-item .layer.crisis { color: #fc8181; }
        .break-item .layer.pending { color: var(--text-muted); font-style: italic; }
        
        .legend { display: flex; flex-direction: column; gap: 8px; }
        .legend-row { display: flex; align-items: center; gap: 8px; }
        .legend-label { width: 50px; font-size: 0.75rem; }
        .legend-gradient { flex: 1; height: 12px; border-radius: 4px; }
        .legend-gradient.spirit { background: linear-gradient(to right, #000, #805ad5); }
        .legend-gradient.soul { background: linear-gradient(to right, #000, #3182ce); }
        .legend-gradient.body { background: linear-gradient(to right, #000, #38a169); }
        .legend-labels { display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-muted); margin-top: 4px; margin-left: 58px; }
        
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; }
        .modal { background: var(--card); border: 1px solid var(--border); border-radius: 16px; max-width: 500px; width: 100%; max-height: 80vh; overflow-y: auto; }
        .modal-header { padding: 20px 24px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .modal-header h2 { font-size: 1.2rem; margin: 0; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; padding: 0; line-height: 1; }
        .modal-close:hover { color: var(--text); }
        .modal-body { padding: 24px; }
        .modal-section { margin-bottom: 20px; }
        .modal-section:last-child { margin-bottom: 0; }
        .modal-section h4 { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
        .modal-section p { line-height: 1.6; }
        
        .focus-cell { display: flex; align-items: center; gap: 12px; padding: 16px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 16px; }
        .focus-cell .cell-code { font-size: 2rem; font-weight: bold; }
        .focus-cell .cell-code.spirit { color: var(--spirit); }
        .focus-cell .cell-code.soul { color: var(--soul); }
        .focus-cell .cell-code.body { color: var(--body); }
        .focus-cell .cell-info-text { flex: 1; }
        .focus-cell .cell-name { font-weight: bold; font-size: 1.1rem; }
        .focus-cell .cell-layer { color: var(--text-muted); font-size: 0.85rem; }
        .focus-cell .cell-score { font-size: 1.5rem; font-weight: bold; }
        .focus-cell .cell-score.weak { color: #fc8181; }
        
        .advice-box { font-size: 1rem; line-height: 1.7; padding: 16px; background: rgba(88, 166, 255, 0.1); border-radius: 8px; border-left: 3px solid var(--accent); }
        .scripture-box { margin-top: 16px; padding: 16px; background: rgba(104, 211, 145, 0.1); border-radius: 8px; border-left: 3px solid #68d391; }
        .scripture-text { font-style: italic; font-size: 1rem; line-height: 1.6; margin-bottom: 8px; }
        .scripture-ref { font-size: 0.85rem; color: #68d391; font-weight: bold; }
        
        .export-section { margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); }
        .export-section textarea { width: 100%; height: 80px; background: var(--bg); border: 1px solid var(--border); border-radius: 8px; color: var(--text); padding: 12px; font-family: monospace; font-size: 0.8rem; resize: vertical; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Diagnostic Assessment</h1>
        <p class="subtitle">Find your break points efficiently</p>
        
        <!-- Phase: Mode Selection -->
        <div id="phase-start" class="card">
            <h2>Choose Assessment Mode</h2>
            <div class="mode-grid">
                <button class="mode-btn" onclick="startQuickMode()">
                    <h3>Quick Assessment</h3>
                    <p>Focus on one dimension at a time. Great for a quick check-in or when time is limited.</p>
                    <div class="estimate">~12-15 questions per dimension</div>
                </button>
                <button class="mode-btn" onclick="startFullMode()">
                    <h3>Full Assessment</h3>
                    <p>Assess all 9 dimensions with interleaved questions. Harder to game, more accurate results.</p>
                    <div class="estimate">~100 questions total • 30-45 minutes</div>
                </button>
            </div>
            <div id="resume-section" class="resume-section hidden">
                <div class="resume-info" id="resume-info"></div>
                <div class="btn-row" style="justify-content: flex-start;">
                    <button class="btn" onclick="resumeAssessment()">Resume Progress</button>
                    <button class="btn btn-secondary btn-small" onclick="clearProgress()">Clear &amp; Start Fresh</button>
                </div>
            </div>
        </div>
        
        <!-- Phase: Dimension Selection (Quick Mode) -->
        <div id="phase-select" class="card hidden">
            <h2>Select a Dimension</h2>
            <div class="dim-grid" id="dim-grid"></div>
            <div class="btn-row" style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="showStart()">Back</button>
                <button class="btn" id="view-results-btn" onclick="viewCurrentResults()" style="display: none;">View Results</button>
            </div>
        </div>
        
        <!-- Phase: Questions -->
        <div id="phase-questions" class="card hidden">
            <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width: 0%"></div></div>
            <div class="cell-info">
                <div>
                    <span class="cell-label" id="cell-label">A1</span>
                    <span class="cell-layer" id="cell-layer">Order</span>
                    <span class="confidence-indicator" id="confidence-indicator">probing</span>
                </div>
                <span class="question-counter" id="question-counter">Q1</span>
            </div>
            <div class="question-voice" id="question-voice"></div>
            <div class="question-text" id="question-text"></div>
            <div class="answers" id="answers"></div>
            <div class="progress-summary" id="progress-summary"></div>
        </div>
        
        <!-- Phase: Processing -->
        <div id="phase-processing" class="card hidden">
            <div class="processing"><div class="spinner"></div><p>Analyzing results...</p></div>
        </div>
        
        <!-- Phase: Results -->
        <div id="phase-results" class="hidden">
            <div class="results-layout">
                <div class="wheel-section">
                    <div class="card">
                        <div class="result-summary">
                            <h3 id="result-title">Assessment Complete</h3>
                            <p class="break-info" id="break-info"></p>
                            <p class="result-stats" id="result-stats"></p>
                        </div>
                        <div class="wheel-container">
                            <svg id="wheel" viewBox="-260 -260 520 520" width="400" height="400"></svg>
                        </div>
                        <div class="btn-row">
                            <button class="btn btn-primary" id="whats-next-btn" onclick="showWhatsNext()">What's Next?</button>
                            <button class="btn" id="continue-btn" onclick="continueAssessment()">Continue</button>
                            <button class="btn btn-secondary" onclick="showStart()">Menu</button>
                        </div>
                        <div class="export-section">
                            <button class="btn btn-small btn-secondary" onclick="toggleExport()">Export/Import Data</button>
                            <div id="export-area" class="hidden" style="margin-top: 12px;">
                                <textarea id="export-data" readonly></textarea>
                                <div class="btn-row" style="margin-top: 8px; justify-content: flex-start;">
                                    <button class="btn btn-small" onclick="copyExport()">Copy</button>
                                    <button class="btn btn-small btn-secondary" onclick="importData()">Import</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="sidebar">
                    <div class="card hover-info" id="hover-info">
                        <h3>Cell Details</h3>
                        <div class="cell-name" id="hover-cell-name">Hover over wheel</div>
                        <div class="cell-detail" id="hover-cell-detail">—</div>
                        <div class="cell-score" id="hover-cell-score">—</div>
                        <div class="cell-status" id="hover-cell-status"></div>
                    </div>
                    <div class="card">
                        <h3>Limiting Factors</h3>
                        <div class="category-scores" id="category-scores"></div>
                        <div class="overall-row">
                            <span class="label">Overall</span>
                            <span class="score" id="overall-score">—</span>
                        </div>
                    </div>
                    <div class="card">
                        <h3>Break Points</h3>
                        <div class="breaks-list" id="breaks-list"></div>
                    </div>
                    <div class="card">
                        <h3>Legend</h3>
                        <div class="legend">
                            <div class="legend-row"><span class="legend-label" style="color: var(--spirit)">Spirit</span><div class="legend-gradient spirit"></div></div>
                            <div class="legend-row"><span class="legend-label" style="color: var(--soul)">Soul</span><div class="legend-gradient soul"></div></div>
                            <div class="legend-row"><span class="legend-label" style="color: var(--body)">Body</span><div class="legend-gradient body"></div></div>
                        </div>
                        <div class="legend-labels"><span>2 (Crisis)</span><span>10 (Exceptional)</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- What's Next Modal -->
    <div id="whats-next-modal" class="modal-overlay hidden">
        <div class="modal">
            <div class="modal-header">
                <h2>What's Next?</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body"></div>
        </div>
    </div>
    
    <script>
    // ============================================
    // CONSTANTS
    // ============================================
    const DIMENSIONS = {
        A: { name: 'Communion', category: 'Spirit' },
        B: { name: 'Conscience', category: 'Spirit' },
        C: { name: 'Holiness', category: 'Spirit' },
        D: { name: 'Mind', category: 'Soul' },
        E: { name: 'Will', category: 'Soul' },
        F: { name: 'Emotions', category: 'Soul' },
        G: { name: 'Sustenance', category: 'Body' },
        H: { name: 'Capability', category: 'Body' },
        I: { name: 'Wholeness', category: 'Body' },
    };
    
    const LAYERS = { 1: 'Order', 2: 'Causality', 3: 'Responsibility', 4: 'Discipline', 5: 'Skill', 6: 'Resources', 7: 'Fellowship', 8: 'Sacrifice' };
    const CATEGORIES = { Spirit: ['A', 'B', 'C'], Soul: ['D', 'E', 'F'], Body: ['G', 'H', 'I'] };
    const LIKERT_SCALE = { 1: 'Strongly Disagree', 2: 'Disagree', 3: 'Neutral / Unsure', 4: 'Agree', 5: 'Strongly Agree' };
    const DIM_ORDER = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    const THRESHOLD = 3.5, DISPLAY_THRESHOLD = 7, DATA_PATH = '/data/questions/';
    const STORAGE_KEY = 'wheel_diagnostic_v1';
    
    // Adaptive questioning
    const MIN_ANSWERS = 2;
    const MAX_ANSWERS = 5;
    const STRONG_THRESHOLD = 4;  // Answers >= this are "strong"
    const WEAK_THRESHOLD = 2;    // Answers <= this are "weak"
    
    // ============================================
    // STATE
    // ============================================
    let state = {
        mode: null,              // 'quick' or 'full'
        activeDims: [],          // Which dimensions are being assessed
        answers: {},             // { A: { 1: [responses], 2: [...], ... }, B: {...}, ... }
        cellData: {},            // Cached JSON data { 'A1': {...}, 'A2': {...}, ... }
        usedQuestions: {},       // { 'A1': Set([questionIds]), ... }
        totalQuestions: 0,
    };
    
    let currentQuestion = null;  // { dim, layer, question, cellData }
    let fullData = null;
    let highlightMarker = null;
    
    // ============================================
    // PERSISTENCE
    // ============================================
    function saveState() {
        const toSave = {
            mode: state.mode,
            activeDims: state.activeDims,
            answers: state.answers,
            usedQuestions: {},
            totalQuestions: state.totalQuestions,
        };
        // Convert Sets to arrays for JSON
        for (const key in state.usedQuestions) {
            toSave.usedQuestions[key] = [...state.usedQuestions[key]];
        }
        localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
    }
    
    function loadState() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return null;
            const parsed = JSON.parse(saved);
            // Convert arrays back to Sets
            if (parsed.usedQuestions) {
                for (const key in parsed.usedQuestions) {
                    parsed.usedQuestions[key] = new Set(parsed.usedQuestions[key]);
                }
            }
            return parsed;
        } catch (e) {
            return null;
        }
    }
    
    function clearState() {
        localStorage.removeItem(STORAGE_KEY);
        state = { mode: null, activeDims: [], answers: {}, cellData: {}, usedQuestions: {}, totalQuestions: 0 };
    }
    
    function getExportData() {
        const toExport = {
            mode: state.mode,
            activeDims: state.activeDims,
            answers: state.answers,
            totalQuestions: state.totalQuestions,
            exportedAt: new Date().toISOString(),
        };
        return JSON.stringify(toExport);
    }
    
    function toggleExport() {
        const area = document.getElementById('export-area');
        area.classList.toggle('hidden');
        if (!area.classList.contains('hidden')) {
            document.getElementById('export-data').value = getExportData();
        }
    }
    
    function copyExport() {
        const textarea = document.getElementById('export-data');
        textarea.select();
        document.execCommand('copy');
        alert('Copied to clipboard!');
    }
    
    function importData() {
        const data = prompt('Paste exported data:');
        if (!data) return;
        try {
            const parsed = JSON.parse(data);
            state.mode = parsed.mode;
            state.activeDims = parsed.activeDims;
            state.answers = parsed.answers;
            state.totalQuestions = parsed.totalQuestions;
            state.usedQuestions = {};
            saveState();
            alert('Data imported successfully!');
            viewCurrentResults();
        } catch (e) {
            alert('Invalid data format');
        }
    }
    
    // ============================================
    // PHASE MANAGEMENT
    // ============================================
    function showPhase(phase) {
        ['start', 'select', 'questions', 'processing', 'results'].forEach(p => {
            document.getElementById(`phase-${p}`).classList.add('hidden');
        });
        document.getElementById(`phase-${phase}`).classList.remove('hidden');
    }
    
    function showStart() {
        showPhase('start');
        checkForSavedProgress();
    }
    
    function checkForSavedProgress() {
        const saved = loadState();
        const section = document.getElementById('resume-section');
        const info = document.getElementById('resume-info');
        
        if (saved && saved.totalQuestions > 0) {
            const dims = saved.activeDims.length === 9 ? 'all dimensions' : saved.activeDims.join(', ');
            const complete = getCompletedDims(saved.answers);
            info.textContent = `Found saved progress: ${saved.totalQuestions} questions answered, ${complete.length}/9 dimensions complete (${saved.mode} mode)`;
            section.classList.remove('hidden');
        } else {
            section.classList.add('hidden');
        }
    }
    
    function resumeAssessment() {
        const saved = loadState();
        if (saved) {
            state.mode = saved.mode;
            state.activeDims = saved.activeDims;
            state.answers = saved.answers;
            state.usedQuestions = saved.usedQuestions || {};
            state.totalQuestions = saved.totalQuestions;
            
            if (isAssessmentComplete()) {
                viewCurrentResults();
            } else {
                showPhase('questions');
                askNextQuestion();
            }
        }
    }
    
    function clearProgress() {
        if (confirm('Are you sure? This will delete all saved progress.')) {
            clearState();
            checkForSavedProgress();
        }
    }
    
    // ============================================
    // MODE SELECTION
    // ============================================
    function startQuickMode() {
        state.mode = 'quick';
        state.activeDims = [];
        state.answers = {};
        state.usedQuestions = {};
        state.totalQuestions = 0;
        showPhase('select');
        renderDimensionGrid();
    }
    
    function startFullMode() {
        state.mode = 'full';
        state.activeDims = [...DIM_ORDER];
        state.answers = {};
        state.usedQuestions = {};
        state.totalQuestions = 0;
        
        // Initialize answer structure for all dimensions
        DIM_ORDER.forEach(dim => {
            state.answers[dim] = {};
            for (let l = 1; l <= 8; l++) state.answers[dim][l] = [];
        });
        
        saveState();
        showPhase('questions');
        askNextQuestion();
    }
    
    function selectDimension(dim) {
        if (getCompletedDims(state.answers).includes(dim)) return;
        
        state.activeDims = [dim];
        if (!state.answers[dim]) {
            state.answers[dim] = {};
            for (let l = 1; l <= 8; l++) state.answers[dim][l] = [];
        }
        
        saveState();
        showPhase('questions');
        askNextQuestion();
    }
    
    function renderDimensionGrid() {
        const grid = document.getElementById('dim-grid');
        grid.innerHTML = '';
        const completed = getCompletedDims(state.answers);
        
        DIM_ORDER.forEach(code => {
            const info = DIMENSIONS[code];
            const btn = document.createElement('button');
            btn.className = `dim-btn ${info.category.toLowerCase()}`;
            if (completed.includes(code)) btn.classList.add('completed');
            btn.innerHTML = `<span class="code">${code}</span><span class="name">${info.name}</span>`;
            btn.onclick = () => selectDimension(code);
            grid.appendChild(btn);
        });
        
        document.getElementById('view-results-btn').style.display = completed.length > 0 ? 'inline-block' : 'none';
    }
    
    function continueAssessment() {
        if (state.mode === 'quick') {
            showPhase('select');
            renderDimensionGrid();
        } else {
            showPhase('questions');
            askNextQuestion();
        }
    }
    
    // ============================================
    // CORE ENGINE - Pure Functions
    // ============================================
    
    // Get average score for a cell, or null if not enough data
    function getCellScore(answers) {
        if (!answers || answers.length === 0) return null;
        return answers.reduce((a, b) => a + b, 0) / answers.length;
    }
    
    // Is the cell "decided" - enough confidence to move on?
    function isCellDecided(answers) {
        if (!answers || answers.length === 0) return false;
        if (answers.length >= MAX_ANSWERS) return true;
        if (answers.length >= MIN_ANSWERS) {
            const allStrong = answers.every(a => a >= STRONG_THRESHOLD);
            const allWeak = answers.every(a => a <= WEAK_THRESHOLD);
            if (allStrong || allWeak) return true;
        }
        return false;
    }
    
    // Get computed scores for a dimension (only decided cells)
    function getDimScores(dimAnswers) {
        const scores = {};
        for (let l = 1; l <= 8; l++) {
            if (dimAnswers[l] && isCellDecided(dimAnswers[l])) {
                scores[l] = getCellScore(dimAnswers[l]);
            }
        }
        return scores;
    }
    
    // Determine what layer a dimension needs to probe next (pure function)
    function getNextLayer(scores) {
        // Initial probes: L3, L6
        if (scores[3] === undefined) return 3;
        if (scores[6] === undefined) return 6;
        
        const l3Strong = scores[3] >= THRESHOLD;
        const l6Strong = scores[6] >= THRESHOLD;
        
        if (l3Strong && l6Strong) {
            // Both strong - check upper layers
            if (scores[7] === undefined) return 7;
            if (scores[8] === undefined) return 8;
            return null; // Done - solid
        }
        
        if (!l3Strong && !l6Strong) {
            // Both weak - problem is low
            if (scores[2] === undefined) return 2;
            if (scores[1] === undefined) return 1;
            // Find break point
            if (scores[1] >= THRESHOLD) return null; // Break at 2
            if (scores[2] >= THRESHOLD) return null; // Break at 3
            return null; // Break at 1
        }
        
        if (l3Strong && !l6Strong) {
            // Break between 4-6
            if (scores[4] === undefined) return 4;
            if (scores[5] === undefined) return 5;
            return null; // Have enough to determine
        }
        
        // l3 weak, l6 strong - unusual, probe more
        if (scores[2] === undefined) return 2;
        if (scores[1] === undefined) return 1;
        if (scores[4] === undefined) return 4;
        if (scores[5] === undefined) return 5;
        return null;
    }
    
    // Is a dimension complete?
    function isDimComplete(dimAnswers) {
        const scores = getDimScores(dimAnswers);
        return getNextLayer(scores) === null;
    }
    
    // Get completed dimensions
    function getCompletedDims(answers) {
        return DIM_ORDER.filter(dim => answers[dim] && isDimComplete(answers[dim]));
    }
    
    // Find break point for a dimension
    function findBreakPoint(dimAnswers) {
        const scores = getDimScores(dimAnswers);
        let floor = 0, bp = null;
        
        for (let layer = 1; layer <= 8; layer++) {
            if (scores[layer] !== undefined) {
                if (scores[layer] >= THRESHOLD) floor = layer;
                else if (bp === null) bp = layer;
            }
        }
        
        if (bp === null && floor > 0) return { floor: 8, break: null };
        if (floor === 0 && (scores[1] === undefined || scores[1] < THRESHOLD)) return { floor: 0, break: 1 };
        return { floor, break: bp };
    }
    
    // Find the weakest break point across all completed dimensions
    function findWeakestBreak() {
        let weakest = null;
        
        for (const dim of DIM_ORDER) {
            if (!state.answers[dim] || !isDimComplete(state.answers[dim])) continue;
            
            const { break: bp } = findBreakPoint(state.answers[dim]);
            if (bp !== null) {
                const scores = getDimScores(state.answers[dim]);
                const score = scores[bp];
                
                if (!weakest || bp < weakest.layer || (bp === weakest.layer && score < weakest.score)) {
                    weakest = { dim, layer: bp, score };
                }
            }
        }
        return weakest;
    }
    
    // ============================================
    // QUESTION FLOW
    // ============================================
    
    function isAssessmentComplete() {
        for (const dim of state.activeDims) {
            if (!isDimComplete(state.answers[dim])) return false;
        }
        return true;
    }
    
    async function askNextQuestion() {
        if (isAssessmentComplete()) {
            showPhase('processing');
            setTimeout(() => {
                showPhase('results');
                displayResults();
            }, 500);
            return;
        }
        
        // Find dimensions that need work
        const needsWork = state.activeDims.filter(dim => !isDimComplete(state.answers[dim]));
        
        // Randomly select one
        const dim = needsWork[Math.floor(Math.random() * needsWork.length)];
        const scores = getDimScores(state.answers[dim]);
        const layer = getNextLayer(scores);
        
        // Load cell data
        const cellKey = `${dim}${layer}`;
        if (!state.cellData[cellKey]) {
            try {
                const response = await fetch(`${DATA_PATH}${cellKey}.json`);
                state.cellData[cellKey] = await response.json();
            } catch (e) {
                console.error('Failed to load cell:', e);
                // Record neutral score and move on
                state.answers[dim][layer] = [3, 3];
                saveState();
                askNextQuestion();
                return;
            }
        }
        
        const cellData = state.cellData[cellKey];
        
        // Track used questions
        if (!state.usedQuestions[cellKey]) {
            state.usedQuestions[cellKey] = new Set();
        }
        
        // Find unused question
        const available = cellData.questions.filter(q => !state.usedQuestions[cellKey].has(q.id));
        if (available.length === 0) {
            // All questions used - cell is maxed out
            if (!isCellDecided(state.answers[dim][layer])) {
                // Force decision with what we have
                state.answers[dim][layer].push(3); // Neutral to trigger decision
            }
            saveState();
            askNextQuestion();
            return;
        }
        
        // Random question from available
        const question = available[Math.floor(Math.random() * available.length)];
        
        currentQuestion = { dim, layer, question, cellData };
        displayQuestion();
    }
    
    function displayQuestion() {
        const { dim, layer, question } = currentQuestion;
        const info = DIMENSIONS[dim];
        const cellAnswers = state.answers[dim][layer] || [];
        
        document.getElementById('cell-label').textContent = `${dim}${layer}: ${info.name}`;
        document.getElementById('cell-layer').textContent = `Layer ${layer}: ${LAYERS[layer]}`;
        
        const confidenceEl = document.getElementById('confidence-indicator');
        confidenceEl.textContent = `${cellAnswers.length}/${MAX_ANSWERS}`;
        
        document.getElementById('question-counter').textContent = `Q${state.totalQuestions + 1}`;
        document.getElementById('question-voice').textContent = question.voice ? `Voice: ${question.voice}` : '';
        document.getElementById('question-text').textContent = question.text;
        
        const answersEl = document.getElementById('answers');
        answersEl.innerHTML = '';
        
        const hasCustom = question.answers && typeof question.answers === 'object';
        for (let i = 1; i <= 5; i++) {
            const btn = document.createElement('button');
            btn.className = 'answer-btn';
            const text = hasCustom ? (question.answers[i] || question.answers[String(i)] || LIKERT_SCALE[i]) : LIKERT_SCALE[i];
            btn.innerHTML = `<span class="score-label">${i}.</span> ${text}`;
            btn.onclick = () => recordAnswer(i);
            answersEl.appendChild(btn);
        }
        
        // Progress bar
        const completed = getCompletedDims(state.answers).length;
        const total = state.activeDims.length;
        const progress = total > 0 ? (completed / total) * 100 : 0;
        document.getElementById('progress-fill').style.width = `${progress}%`;
        
        // Progress pips
        renderProgressPips();
    }
    
    function renderProgressPips() {
        const container = document.getElementById('progress-summary');
        container.innerHTML = '';
        
        state.activeDims.forEach(dim => {
            const pip = document.createElement('div');
            pip.className = 'progress-pip';
            pip.title = `${dim}: ${DIMENSIONS[dim].name}`;
            
            if (isDimComplete(state.answers[dim])) {
                pip.classList.add('complete');
            } else if (currentQuestion && currentQuestion.dim === dim) {
                pip.classList.add('active');
            }
            container.appendChild(pip);
        });
    }
    
    function recordAnswer(score) {
        const { dim, layer, question } = currentQuestion;
        
        state.answers[dim][layer].push(score);
        state.usedQuestions[`${dim}${layer}`].add(question.id);
        state.totalQuestions++;
        
        saveState();
        askNextQuestion();
    }
    
    // ============================================
    // RESULTS
    // ============================================
    
    function buildFullData() {
        const data = {};
        DIM_ORDER.forEach(dim => {
            data[dim] = {};
            const dimAnswers = state.answers[dim] || {};
            const scores = getDimScores(dimAnswers);
            
            for (let layer = 1; layer <= 8; layer++) {
                if (scores[layer] !== undefined) {
                    data[dim][layer] = scores[layer];
                } else if (dimAnswers[layer] && dimAnswers[layer].length > 0) {
                    // Has answers but not decided - use current average
                    data[dim][layer] = getCellScore(dimAnswers[layer]);
                } else {
                    data[dim][layer] = null; // Not assessed
                }
            }
            
            // Fill gaps with interpolation for completed dims
            if (isDimComplete(dimAnswers)) {
                for (let layer = 1; layer <= 8; layer++) {
                    if (data[dim][layer] === null) {
                        let below = null, above = null;
                        for (let l = layer - 1; l >= 1; l--) if (data[dim][l] !== null) { below = data[dim][l]; break; }
                        for (let l = layer + 1; l <= 8; l++) if (data[dim][l] !== null) { above = data[dim][l]; break; }
                        if (below !== null && above !== null) data[dim][layer] = (below + above) / 2;
                        else if (below !== null) data[dim][layer] = below * 0.9;
                        else if (above !== null) data[dim][layer] = Math.min(5, above * 1.1);
                        else data[dim][layer] = 3.0;
                    }
                }
            }
        });
        return data;
    }
    
    function displayResults() {
        fullData = buildFullData();
        
        const completed = getCompletedDims(state.answers);
        const weakest = findWeakestBreak();
        const allDone = completed.length === state.activeDims.length;
        
        const titleEl = document.getElementById('result-title');
        const infoEl = document.getElementById('break-info');
        const statsEl = document.getElementById('result-stats');
        const continueBtn = document.getElementById('continue-btn');
        const whatsNextBtn = document.getElementById('whats-next-btn');
        
        if (allDone && state.activeDims.length === 9) {
            titleEl.textContent = 'Full Assessment Complete';
            if (weakest) {
                infoEl.className = 'break-info';
                infoEl.innerHTML = `Primary focus: <strong>${weakest.dim}${weakest.layer} ${DIMENSIONS[weakest.dim].name} — ${LAYERS[weakest.layer]}</strong>`;
            } else {
                infoEl.className = 'break-info solid';
                infoEl.innerHTML = '<strong>All solid!</strong> No break points found';
            }
            continueBtn.classList.add('hidden');
        } else if (allDone) {
            titleEl.textContent = `${completed.length} Dimension${completed.length > 1 ? 's' : ''} Complete`;
            if (weakest) {
                infoEl.className = 'break-info';
                infoEl.innerHTML = `Focus: <strong>${weakest.dim}${weakest.layer} — ${LAYERS[weakest.layer]}</strong>`;
            } else {
                infoEl.className = 'break-info solid';
                infoEl.innerHTML = '<strong>All assessed dimensions solid</strong>';
            }
            continueBtn.textContent = state.mode === 'quick' ? 'Assess Another' : 'Continue';
            continueBtn.classList.remove('hidden');
        } else {
            titleEl.textContent = 'Progress Update';
            infoEl.className = 'break-info';
            infoEl.innerHTML = `${completed.length}/${state.activeDims.length} dimensions complete`;
            continueBtn.textContent = 'Continue';
            continueBtn.classList.remove('hidden');
        }
        
        statsEl.textContent = `${state.totalQuestions} questions answered`;
        whatsNextBtn.classList.toggle('hidden', !weakest);
        
        renderWheel(fullData);
        renderSidebar(fullData);
    }
    
    function viewCurrentResults() {
        fullData = buildFullData();
        showPhase('results');
        displayResults();
    }
    
    // ============================================
    // WHAT'S NEXT MODAL
    // ============================================
    
    async function showWhatsNext() {
        const weakest = findWeakestBreak();
        if (!weakest) return;
        
        const modal = document.getElementById('whats-next-modal');
        const modalBody = document.getElementById('modal-body');
        
        const cellKey = `${weakest.dim}${weakest.layer}`;
        let cellData = state.cellData[cellKey];
        
        if (!cellData) {
            try {
                const response = await fetch(`${DATA_PATH}${cellKey}.json`);
                cellData = await response.json();
                state.cellData[cellKey] = cellData;
            } catch (e) {
                modalBody.innerHTML = '<p>Unable to load recommendations.</p>';
                modal.classList.remove('hidden');
                return;
            }
        }
        
        const info = DIMENSIONS[weakest.dim];
        const displayScore = (weakest.score * 2).toFixed(1);
        const remediation = cellData.remediation || {};
        
        let html = `
            <div class="focus-cell">
                <div class="cell-code ${info.category.toLowerCase()}">${weakest.dim}${weakest.layer}</div>
                <div class="cell-info-text">
                    <div class="cell-name">${info.name}</div>
                    <div class="cell-layer">Layer ${weakest.layer}: ${LAYERS[weakest.layer]}</div>
                </div>
                <div class="cell-score weak">${displayScore}</div>
            </div>
        `;
        
        if (remediation.advice) {
            html += `<div class="modal-section"><h4>Recommendation</h4><div class="advice-box">${remediation.advice}</div></div>`;
        }
        
        if (remediation.scripture) {
            html += `
                <div class="modal-section">
                    <h4>Scripture</h4>
                    <div class="scripture-box">
                        <div class="scripture-text">"${remediation.scripture.text}"</div>
                        <div class="scripture-ref">— ${remediation.scripture.reference}</div>
                    </div>
                </div>
            `;
        }
        
        if (!remediation.advice && !remediation.scripture) {
            html += `<div class="modal-section"><p>Focus on strengthening <strong>${LAYERS[weakest.layer]}</strong> in your <strong>${info.name}</strong>.</p></div>`;
        }
        
        modalBody.innerHTML = html;
        modal.classList.remove('hidden');
    }
    
    function closeModal() {
        document.getElementById('whats-next-modal').classList.add('hidden');
    }
    
    document.getElementById('whats-next-modal').addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) closeModal();
    });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });
    
    // ============================================
    // SIDEBAR
    // ============================================
    
    function getCategoryMin(data, category) {
        let min = 5, hasData = false;
        const completed = getCompletedDims(state.answers);
        for (const dim of CATEGORIES[category]) {
            if (completed.includes(dim)) {
                hasData = true;
                for (let l = 1; l <= 8; l++) {
                    if (data[dim][l] !== null && data[dim][l] < min) min = data[dim][l];
                }
            }
        }
        return hasData ? min : null;
    }
    
    function getOverallScore(data) {
        const mins = ['Spirit', 'Soul', 'Body'].map(c => getCategoryMin(data, c)).filter(m => m !== null);
        return mins.length > 0 ? Math.min(...mins) : null;
    }
    
    function showCellInfo(dim, layer) {
        const info = DIMENSIONS[dim];
        const score = fullData[dim][layer];
        const completed = getCompletedDims(state.answers);
        const isAssessed = completed.includes(dim);
        
        document.getElementById('hover-cell-name').textContent = `${dim}${layer}: ${info.name}`;
        document.getElementById('hover-cell-name').style.color = getCategoryColor(info.category);
        document.getElementById('hover-cell-detail').textContent = `Layer ${layer}: ${LAYERS[layer]} • ${info.category}`;
        
        const statusEl = document.getElementById('hover-cell-status');
        if (!isAssessed || score === null) {
            document.getElementById('hover-cell-score').textContent = '—';
            statusEl.textContent = 'Not yet assessed';
            statusEl.className = 'cell-status pending';
        } else {
            document.getElementById('hover-cell-score').textContent = (score * 2).toFixed(1);
            const isStrong = score >= THRESHOLD;
            statusEl.textContent = isStrong ? `STRONG (≥${DISPLAY_THRESHOLD})` : `WEAK (<${DISPLAY_THRESHOLD})`;
            statusEl.className = 'cell-status ' + (isStrong ? 'strong' : 'weak');
        }
    }
    
    function resetCellInfo() {
        document.getElementById('hover-cell-name').textContent = 'Hover over wheel';
        document.getElementById('hover-cell-name').style.color = '';
        document.getElementById('hover-cell-detail').textContent = '—';
        document.getElementById('hover-cell-score').textContent = '—';
        document.getElementById('hover-cell-status').textContent = '';
        document.getElementById('hover-cell-status').className = 'cell-status';
    }
    
    function highlightDimension(dim, breakLayerNum) {
        const svg = document.getElementById('wheel');
        svg.querySelectorAll('path[data-dim]').forEach(path => {
            path.style.opacity = path.getAttribute('data-dim') === dim ? '1' : '0.2';
        });
        if (highlightMarker) { highlightMarker.remove(); highlightMarker = null; }
        if (breakLayerNum !== null && breakLayerNum > 0) {
            const dimIndex = DIM_ORDER.indexOf(dim);
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2, endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            const radius = MIN_RADIUS + (breakLayerNum - 1) * RING_WIDTH;
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            marker.setAttribute('d', describeArcLine(CX, CY, radius, startAngle, endAngle));
            marker.setAttribute('stroke', '#ffffff');
            marker.setAttribute('stroke-width', '3');
            marker.setAttribute('fill', 'none');
            marker.setAttribute('stroke-linecap', 'round');
            marker.style.filter = 'drop-shadow(0 0 4px rgba(255,255,255,0.8))';
            svg.appendChild(marker);
            highlightMarker = marker;
        }
    }
    
    function clearHighlight() {
        document.getElementById('wheel').querySelectorAll('path[data-dim]').forEach(path => { path.style.opacity = '1'; });
        if (highlightMarker) { highlightMarker.remove(); highlightMarker = null; }
    }
    
    function renderSidebar(data) {
        const container = document.getElementById('category-scores');
        container.innerHTML = '';
        ['Spirit', 'Soul', 'Body'].forEach(cat => {
            const min = getCategoryMin(data, cat);
            const row = document.createElement('div');
            row.className = 'category-row';
            if (min !== null) {
                const displayMin = (min * 2).toFixed(1);
                const isStrong = min >= THRESHOLD;
                row.innerHTML = `<span class="cat-name ${cat.toLowerCase()}">${cat}</span><span class="cat-score ${isStrong ? 'strong' : 'weak'}">${displayMin}</span>`;
            } else {
                row.innerHTML = `<span class="cat-name ${cat.toLowerCase()}">${cat}</span><span class="cat-score pending">—</span>`;
            }
            container.appendChild(row);
        });
        
        const overall = getOverallScore(data);
        const overallEl = document.getElementById('overall-score');
        if (overall !== null) {
            overallEl.textContent = (overall * 2).toFixed(1);
            overallEl.className = 'score ' + (overall >= THRESHOLD ? 'strong' : 'weak');
        } else {
            overallEl.textContent = '—';
            overallEl.className = 'score pending';
        }
        
        const breaksList = document.getElementById('breaks-list');
        breaksList.innerHTML = '';
        const completed = getCompletedDims(state.answers);
        
        DIM_ORDER.forEach(dim => {
            const info = DIMENSIONS[dim];
            const item = document.createElement('div');
            item.className = 'break-item';
            
            if (completed.includes(dim)) {
                const { break: bp } = findBreakPoint(state.answers[dim]);
                let layerText, layerClass;
                if (bp === null) { layerText = 'Solid'; layerClass = 'solid'; }
                else if (bp === 1) { layerText = 'L1 Crisis'; layerClass = 'crisis'; }
                else { layerText = `L${bp} ${LAYERS[bp]}`; layerClass = ''; }
                item.innerHTML = `<span class="dim ${info.category.toLowerCase()}">${dim} ${info.name}</span><span class="layer ${layerClass}">${layerText}</span>`;
                item.addEventListener('mouseenter', () => highlightDimension(dim, bp));
                item.addEventListener('mouseleave', () => clearHighlight());
            } else {
                item.innerHTML = `<span class="dim ${info.category.toLowerCase()}">${dim} ${info.name}</span><span class="layer pending">Pending</span>`;
                item.style.cursor = 'default';
            }
            breaksList.appendChild(item);
        });
    }
    
    // ============================================
    // WHEEL RENDERING
    // ============================================
    
    const CATEGORY_COLORS = { Spirit: { r: 128, g: 90, b: 213 }, Soul: { r: 49, g: 130, b: 206 }, Body: { r: 56, g: 161, b: 105 } };
    const CX = 0, CY = 0, MIN_RADIUS = 30, MAX_RADIUS = 220;
    const RING_WIDTH = (MAX_RADIUS - MIN_RADIUS) / 8, WEDGE_ANGLE = 360 / 9, GAP = 1;
    
    function scoreToColor(score, category) {
        if (score === null) return '#1a1f26';
        const brightness = (score - 1) / 4;
        const c = CATEGORY_COLORS[category];
        return `rgb(${Math.round(c.r * brightness)}, ${Math.round(c.g * brightness)}, ${Math.round(c.b * brightness)})`;
    }
    
    function getCategoryColor(category) { return { Spirit: '#805ad5', Soul: '#3182ce', Body: '#38a169' }[category]; }
    
    function polarToCartesian(cx, cy, radius, angle) {
        const r = (angle - 90) * Math.PI / 180;
        return { x: cx + radius * Math.cos(r), y: cy + radius * Math.sin(r) };
    }
    
    function describeArc(cx, cy, ir, or, sa, ea) {
        const s1 = polarToCartesian(cx, cy, or, ea), e1 = polarToCartesian(cx, cy, or, sa);
        const s2 = polarToCartesian(cx, cy, ir, sa), e2 = polarToCartesian(cx, cy, ir, ea);
        const laf = ea - sa <= 180 ? "0" : "1";
        return `M ${s1.x} ${s1.y} A ${or} ${or} 0 ${laf} 0 ${e1.x} ${e1.y} L ${s2.x} ${s2.y} A ${ir} ${ir} 0 ${laf} 1 ${e2.x} ${e2.y} Z`;
    }
    
    function describeArcLine(cx, cy, r, sa, ea) {
        const s = polarToCartesian(cx, cy, r, sa), e = polarToCartesian(cx, cy, r, ea);
        return `M ${s.x} ${s.y} A ${r} ${r} 0 ${ea - sa <= 180 ? "0" : "1"} 1 ${e.x} ${e.y}`;
    }
    
    function getEarliestBreak(data) {
        const completed = getCompletedDims(state.answers);
        let earliest = null;
        for (const dim of completed) {
            const { break: bp } = findBreakPoint(state.answers[dim]);
            if (bp !== null && (earliest === null || bp < earliest)) earliest = bp;
        }
        return earliest;
    }
    
    function renderFace(svg, eb) {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        const completed = getCompletedDims(state.answers);
        let color, mouth;
        
        if (completed.length === 0) { color = '#6e7681'; mouth = 'M -8 6 L 8 6'; }
        else if (eb === null || eb >= 6) { color = '#68d391'; mouth = 'M -8 4 Q 0 12 8 4'; }
        else if (eb >= 3) { color = '#f6ad55'; mouth = 'M -8 6 L 8 6'; }
        else { color = '#fc8181'; mouth = 'M -8 10 Q 0 4 8 10'; }
        
        [[-6,-4], [6,-4]].forEach(([x,y]) => {
            const e = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            e.setAttribute('cx', x); e.setAttribute('cy', y); e.setAttribute('r', 3); e.setAttribute('fill', color);
            g.appendChild(e);
        });
        const m = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        m.setAttribute('d', mouth); m.setAttribute('stroke', color); m.setAttribute('stroke-width', '2.5');
        m.setAttribute('stroke-linecap', 'round'); m.setAttribute('fill', 'none');
        g.appendChild(m); svg.appendChild(g);
    }
    
    function renderWheel(data) {
        const svg = document.getElementById('wheel');
        svg.innerHTML = '';
        
        DIM_ORDER.forEach((dim, di) => {
            const sa = di * WEDGE_ANGLE + GAP/2, ea = (di + 1) * WEDGE_ANGLE - GAP/2;
            const cat = DIMENSIONS[dim].category;
            
            for (let l = 1; l <= 8; l++) {
                const ir = MIN_RADIUS + (l-1) * RING_WIDTH + 1, or = MIN_RADIUS + l * RING_WIDTH - 1;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', describeArc(CX, CY, ir, or, sa, ea));
                path.setAttribute('fill', scoreToColor(data[dim][l], cat));
                path.setAttribute('stroke', '#0d1117'); path.setAttribute('stroke-width', '1');
                path.setAttribute('data-dim', dim); path.setAttribute('data-layer', l);
                path.style.cursor = 'pointer'; path.style.transition = 'opacity 0.15s';
                path.addEventListener('mouseenter', () => { showCellInfo(dim, l); path.style.opacity = '0.8'; });
                path.addEventListener('mouseleave', () => { path.style.opacity = '1'; resetCellInfo(); });
                svg.appendChild(path);
            }
        });
        
        DIM_ORDER.forEach((dim, di) => {
            const pos = polarToCartesian(CX, CY, MAX_RADIUS + 20, (di + 0.5) * WEDGE_ANGLE);
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', pos.x); t.setAttribute('y', pos.y);
            t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
            t.setAttribute('fill', getCategoryColor(DIMENSIONS[dim].category));
            t.setAttribute('font-size', '12'); t.setAttribute('font-weight', 'bold');
            t.textContent = dim; svg.appendChild(t);
        });
        
        for (let l = 1; l <= 8; l++) {
            const pos = polarToCartesian(CX, CY, MIN_RADIUS + (l - 0.5) * RING_WIDTH, -10);
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            t.setAttribute('x', pos.x); t.setAttribute('y', pos.y);
            t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
            t.setAttribute('fill', '#6e7681'); t.setAttribute('font-size', '8');
            t.textContent = `L${l}`; svg.appendChild(t);
        }
        
        const cc = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        cc.setAttribute('cx', CX); cc.setAttribute('cy', CY); cc.setAttribute('r', MIN_RADIUS - 2); cc.setAttribute('fill', '#0d1117');
        svg.appendChild(cc);
        
        renderFace(svg, getEarliestBreak(data));
    }
    
    // ============================================
    // INIT
    // ============================================
    
    showStart();
    </script>
</body>
</html>
