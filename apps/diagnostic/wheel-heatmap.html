<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheel Heatmap - Diagnostic POC</title>
    <style>
        :root {
            --spirit: #805ad5;
            --soul: #3182ce;
            --body: #38a169;
            --bg: #0d1117;
            --card: #161b22;
            --text: #e2e8f0;
            --text-muted: #6e7681;
            --border: #30363d;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: var(--text-muted);
            margin-bottom: 24px;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .controls button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--card);
            color: var(--text);
            cursor: pointer;
        }
        
        .controls button:hover {
            background: var(--border);
        }
        
        .status {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 24px;
        }
        
        @media (max-width: 800px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .wheel-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        #wheel {
            max-width: 100%;
            height: auto;
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border);
        }
        
        .card h3 {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }
        
        .hover-info {
            min-height: 80px;
        }
        
        .hover-info .cell-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .hover-info .cell-detail {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 8px;
        }
        
        .hover-info .cell-score {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .hover-info .cell-status {
            font-size: 0.85rem;
            margin-top: 4px;
        }
        
        .hover-info .cell-status.strong { color: #68d391; }
        .hover-info .cell-status.weak { color: #fc8181; }
        
        .breaks-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .break-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .break-item:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .break-item .dim {
            font-weight: bold;
        }
        
        .break-item .dim.spirit { color: var(--spirit); }
        .break-item .dim.soul { color: var(--soul); }
        .break-item .dim.body { color: var(--body); }
        
        .break-item .layer {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .break-item .layer.solid {
            color: #68d391;
        }
        
        .break-item .layer.crisis {
            color: #fc8181;
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-label {
            width: 50px;
            font-size: 0.75rem;
        }
        
        .legend-gradient {
            flex: 1;
            height: 12px;
            border-radius: 4px;
        }
        
        .legend-gradient.spirit {
            background: linear-gradient(to right, #000, #805ad5);
        }
        
        .legend-gradient.soul {
            background: linear-gradient(to right, #000, #3182ce);
        }
        
        .legend-gradient.body {
            background: linear-gradient(to right, #000, #38a169);
        }
        
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
            margin-left: 58px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Wheel Heatmap</h1>
        <p class="subtitle">72 cells — brightness = strength, color = category</p>
        
        <div class="controls">
            <button onclick="randomize()">Randomize Data</button>
            <span class="status" id="status"></span>
        </div>
        
        <div class="main-layout">
            <div class="wheel-container">
                <svg id="wheel" viewBox="-260 -260 520 520" width="500" height="500"></svg>
            </div>
            
            <div class="sidebar">
                <div class="card hover-info" id="hover-info">
                    <h3>Cell Details</h3>
                    <div class="cell-name" id="cell-name">Hover over a cell</div>
                    <div class="cell-detail" id="cell-detail">—</div>
                    <div class="cell-score" id="cell-score">—</div>
                    <div class="cell-status" id="cell-status"></div>
                </div>
                
                <div class="card">
                    <h3>Break Points</h3>
                    <div class="breaks-list" id="breaks-list"></div>
                </div>
                
                <div class="card">
                    <h3>Legend</h3>
                    <div class="legend">
                        <div class="legend-row">
                            <span class="legend-label" style="color: var(--spirit)">Spirit</span>
                            <div class="legend-gradient spirit"></div>
                        </div>
                        <div class="legend-row">
                            <span class="legend-label" style="color: var(--soul)">Soul</span>
                            <div class="legend-gradient soul"></div>
                        </div>
                        <div class="legend-row">
                            <span class="legend-label" style="color: var(--body)">Body</span>
                            <div class="legend-gradient body"></div>
                        </div>
                    </div>
                    <div class="legend-labels">
                        <span>2 (Crisis)</span>
                        <span>10 (Exceptional)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    const DIMENSIONS = {
        A: { name: 'Communion', category: 'Spirit' },
        B: { name: 'Conscience', category: 'Spirit' },
        C: { name: 'Holiness', category: 'Spirit' },
        D: { name: 'Mind', category: 'Soul' },
        E: { name: 'Will', category: 'Soul' },
        F: { name: 'Emotions', category: 'Soul' },
        G: { name: 'Sustenance', category: 'Body' },
        H: { name: 'Capability', category: 'Body' },
        I: { name: 'Wholeness', category: 'Body' },
    };
    
    const LAYERS = {
        1: 'Order',
        2: 'Causality', 
        3: 'Responsibility',
        4: 'Discipline',
        5: 'Skill',
        6: 'Resources',
        7: 'Fellowship',
        8: 'Sacrifice'
    };
    
    // Category base colors (RGB)
    const CATEGORY_COLORS = {
        Spirit: { r: 128, g: 90, b: 213 },   // #805ad5
        Soul:   { r: 49, g: 130, b: 206 },   // #3182ce
        Body:   { r: 56, g: 161, b: 105 },   // #38a169
    };
    
    const DIM_ORDER = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    const THRESHOLD = 3.5; // Internal (1-5 scale)
    const DISPLAY_THRESHOLD = 7; // Display (1-10 scale)
    
    // Wheel geometry constants
    const CX = 0, CY = 0;
    const MIN_RADIUS = 30;
    const MAX_RADIUS = 220;
    const RING_WIDTH = (MAX_RADIUS - MIN_RADIUS) / 8;
    const WEDGE_ANGLE = 360 / 9;
    const GAP = 1;
    
    let data = {};
    let highlightMarker = null;
    
    // Break point weighted distribution
    const breakDistribution = [
        { break: null, weight: 10 },
        { break: 1, weight: 5 },
        { break: 2, weight: 8 },
        { break: 3, weight: 12 },
        { break: 4, weight: 20 },
        { break: 5, weight: 18 },
        { break: 6, weight: 15 },
        { break: 7, weight: 8 },
        { break: 8, weight: 4 },
    ];
    
    function pickBreakPoint() {
        const totalWeight = breakDistribution.reduce((sum, b) => sum + b.weight, 0);
        let random = Math.random() * totalWeight;
        for (const b of breakDistribution) {
            random -= b.weight;
            if (random <= 0) return b.break;
        }
        return 4;
    }
    
    function generateData() {
        data = {};
        
        for (const dim of DIM_ORDER) {
            data[dim] = {};
            const breakPoint = pickBreakPoint();
            
            if (breakPoint === null) {
                let ceiling = 4.5 + Math.random() * 0.5;
                for (let layer = 1; layer <= 8; layer++) {
                    const minScore = Math.max(3.5, ceiling - 0.8);
                    const score = minScore + Math.random() * (ceiling - minScore);
                    data[dim][layer] = Math.round(score * 100) / 100;
                    ceiling = data[dim][layer];
                }
            } else if (breakPoint === 1) {
                let ceiling = 2.0 + Math.random() * 1.4;
                for (let layer = 1; layer <= 8; layer++) {
                    const score = 1 + Math.random() * (ceiling - 1);
                    data[dim][layer] = Math.round(score * 100) / 100;
                    ceiling = data[dim][layer];
                }
            } else {
                const floor = breakPoint - 1;
                let ceiling = 4.2 + Math.random() * 0.8;
                for (let layer = 1; layer <= floor; layer++) {
                    const minScore = Math.max(3.6, ceiling - 0.5);
                    const score = minScore + Math.random() * (ceiling - minScore);
                    data[dim][layer] = Math.round(score * 100) / 100;
                    ceiling = data[dim][layer];
                }
                const breakCeiling = Math.min(data[dim][floor], 3.4);
                const breakScore = 1.5 + Math.random() * (breakCeiling - 1.5);
                data[dim][breakPoint] = Math.round(breakScore * 100) / 100;
                ceiling = data[dim][breakPoint];
                for (let layer = breakPoint + 1; layer <= 8; layer++) {
                    const score = 1 + Math.random() * (ceiling - 1);
                    data[dim][layer] = Math.round(score * 100) / 100;
                    ceiling = data[dim][layer];
                }
            }
        }
    }
    
    function calculateOverallScore() {
        let total = 0;
        let count = 0;
        for (const dim of DIM_ORDER) {
            for (let layer = 1; layer <= 8; layer++) {
                total += data[dim][layer];
                count++;
            }
        }
        return total / count; // Returns 1-5 scale
    }
    
    function findBreakPoint(dimData) {
        let floor = 0;
        let breakPoint = null;
        
        for (let layer = 1; layer <= 8; layer++) {
            if (dimData[layer] >= THRESHOLD) {
                floor = layer;
            } else {
                if (breakPoint === null) {
                    breakPoint = layer;
                }
            }
        }
        
        if (breakPoint === null && floor > 0) {
            return { floor: 8, break: null };
        }
        if (floor === 0) {
            return { floor: 0, break: 1 };
        }
        return { floor, break: breakPoint };
    }
    
    // Convert internal score (1-5) to display score (2-10)
    function toDisplayScore(score) {
        return score * 2;
    }
    
    function scoreToColor(score, category) {
        // Map 1-5 to 0-1 brightness
        const brightness = (score - 1) / 4;
        const baseColor = CATEGORY_COLORS[category];
        
        // Interpolate from black (0,0,0) to category color
        const r = Math.round(baseColor.r * brightness);
        const g = Math.round(baseColor.g * brightness);
        const b = Math.round(baseColor.b * brightness);
        
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    function getCategoryColor(category) {
        switch(category) {
            case 'Spirit': return '#805ad5';
            case 'Soul': return '#3182ce';
            case 'Body': return '#38a169';
        }
    }
    
    function polarToCartesian(cx, cy, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
            x: cx + (radius * Math.cos(angleInRadians)),
            y: cy + (radius * Math.sin(angleInRadians))
        };
    }
    
    function describeArc(cx, cy, innerRadius, outerRadius, startAngle, endAngle) {
        const start1 = polarToCartesian(cx, cy, outerRadius, endAngle);
        const end1 = polarToCartesian(cx, cy, outerRadius, startAngle);
        const start2 = polarToCartesian(cx, cy, innerRadius, startAngle);
        const end2 = polarToCartesian(cx, cy, innerRadius, endAngle);
        
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        
        return [
            "M", start1.x, start1.y,
            "A", outerRadius, outerRadius, 0, largeArcFlag, 0, end1.x, end1.y,
            "L", start2.x, start2.y,
            "A", innerRadius, innerRadius, 0, largeArcFlag, 1, end2.x, end2.y,
            "Z"
        ].join(" ");
    }
    
    function describeArcLine(cx, cy, radius, startAngle, endAngle) {
        const start = polarToCartesian(cx, cy, radius, startAngle);
        const end = polarToCartesian(cx, cy, radius, endAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        
        return [
            "M", start.x, start.y,
            "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y
        ].join(" ");
    }
    
    function renderFace(svg, overallScore) {
        // overallScore is 1-5, convert to display (2-10)
        const displayScore = toDisplayScore(overallScore);
        
        // Thresholds on display scale:
        // >= 7.5: happy (smile)
        // 6.0 - 7.5: neutral (flat)
        // < 6.0: sad (frown)
        
        const faceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        faceGroup.setAttribute('class', 'face');
        
        // Face background circle
        const faceCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        faceCircle.setAttribute('cx', CX);
        faceCircle.setAttribute('cy', CY);
        faceCircle.setAttribute('r', MIN_RADIUS - 4);
        faceCircle.setAttribute('fill', '#0d1117');
        faceGroup.appendChild(faceCircle);
        
        // Determine face color based on score
        let faceColor;
        if (displayScore >= 7.5) {
            faceColor = '#68d391'; // green - happy
        } else if (displayScore >= 6.0) {
            faceColor = '#f6e05e'; // yellow - neutral
        } else {
            faceColor = '#fc8181'; // red - sad
        }
        
        // Eyes
        const eyeRadius = 3;
        const eyeY = CY - 5;
        const eyeSpacing = 10;
        
        const leftEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        leftEye.setAttribute('cx', CX - eyeSpacing);
        leftEye.setAttribute('cy', eyeY);
        leftEye.setAttribute('r', eyeRadius);
        leftEye.setAttribute('fill', faceColor);
        faceGroup.appendChild(leftEye);
        
        const rightEye = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        rightEye.setAttribute('cx', CX + eyeSpacing);
        rightEye.setAttribute('cy', eyeY);
        rightEye.setAttribute('r', eyeRadius);
        rightEye.setAttribute('fill', faceColor);
        faceGroup.appendChild(rightEye);
        
        // Mouth
        const mouthY = CY + 8;
        const mouthWidth = 14;
        const mouth = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        
        let mouthPath;
        if (displayScore >= 7.5) {
            // Smile - arc curving down (appears as smile)
            mouthPath = `M ${CX - mouthWidth} ${mouthY} Q ${CX} ${mouthY + 10} ${CX + mouthWidth} ${mouthY}`;
        } else if (displayScore >= 6.0) {
            // Flat line
            mouthPath = `M ${CX - mouthWidth} ${mouthY} L ${CX + mouthWidth} ${mouthY}`;
        } else {
            // Frown - arc curving up (appears as frown)
            mouthPath = `M ${CX - mouthWidth} ${mouthY + 5} Q ${CX} ${mouthY - 5} ${CX + mouthWidth} ${mouthY + 5}`;
        }
        
        mouth.setAttribute('d', mouthPath);
        mouth.setAttribute('stroke', faceColor);
        mouth.setAttribute('stroke-width', '3');
        mouth.setAttribute('stroke-linecap', 'round');
        mouth.setAttribute('fill', 'none');
        faceGroup.appendChild(mouth);
        
        svg.appendChild(faceGroup);
    }
    
    function renderWheel() {
        const svg = document.getElementById('wheel');
        svg.innerHTML = '';
        
        // Draw cells
        DIM_ORDER.forEach((dim, dimIndex) => {
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2;
            const endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            const category = DIMENSIONS[dim].category;
            
            for (let layer = 1; layer <= 8; layer++) {
                const innerRadius = MIN_RADIUS + (layer - 1) * RING_WIDTH + 1;
                const outerRadius = MIN_RADIUS + layer * RING_WIDTH - 1;
                const score = data[dim][layer];
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', describeArc(CX, CY, innerRadius, outerRadius, startAngle, endAngle));
                path.setAttribute('fill', scoreToColor(score, category));
                path.setAttribute('stroke', '#0d1117');
                path.setAttribute('stroke-width', '1');
                path.setAttribute('data-dim', dim);
                path.setAttribute('data-layer', layer);
                path.style.cursor = 'pointer';
                path.style.transition = 'opacity 0.15s';
                
                path.addEventListener('mouseenter', (e) => {
                    showCellInfo(dim, layer);
                    path.style.opacity = '0.8';
                });
                path.addEventListener('mouseleave', (e) => {
                    path.style.opacity = '1';
                });
                
                svg.appendChild(path);
            }
        });
        
        // Draw dimension labels
        DIM_ORDER.forEach((dim, dimIndex) => {
            const angle = (dimIndex + 0.5) * WEDGE_ANGLE;
            const pos = polarToCartesian(CX, CY, MAX_RADIUS + 25, angle);
            const info = DIMENSIONS[dim];
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', getCategoryColor(info.category));
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = dim;
            svg.appendChild(text);
        });
        
        // Draw layer labels (on one ray)
        for (let layer = 1; layer <= 8; layer++) {
            const radius = MIN_RADIUS + (layer - 0.5) * RING_WIDTH;
            const pos = polarToCartesian(CX, CY, radius, -10);
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', pos.x);
            text.setAttribute('y', pos.y);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#6e7681');
            text.setAttribute('font-size', '9');
            text.textContent = `L${layer}`;
            svg.appendChild(text);
        }
        
        // Draw face in center
        const overallScore = calculateOverallScore();
        renderFace(svg, overallScore);
        
        renderBreaksList();
    }
    
    function highlightDimension(dim, breakLayer) {
        const svg = document.getElementById('wheel');
        
        // Dim all cells except the highlighted dimension
        svg.querySelectorAll('path[data-dim]').forEach(path => {
            if (path.getAttribute('data-dim') === dim) {
                path.style.opacity = '1';
            } else {
                path.style.opacity = '0.2';
            }
        });
        
        // Remove old marker
        if (highlightMarker) {
            highlightMarker.remove();
            highlightMarker = null;
        }
        
        // Draw white arc at break point (if there is one)
        if (breakLayer !== null && breakLayer > 0) {
            const dimIndex = DIM_ORDER.indexOf(dim);
            const startAngle = dimIndex * WEDGE_ANGLE + GAP/2;
            const endAngle = (dimIndex + 1) * WEDGE_ANGLE - GAP/2;
            
            // Draw arc at the inner edge of the break layer
            const radius = MIN_RADIUS + (breakLayer - 1) * RING_WIDTH;
            
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            marker.setAttribute('d', describeArcLine(CX, CY, radius, startAngle, endAngle));
            marker.setAttribute('stroke', '#ffffff');
            marker.setAttribute('stroke-width', '3');
            marker.setAttribute('fill', 'none');
            marker.setAttribute('stroke-linecap', 'round');
            marker.style.filter = 'drop-shadow(0 0 4px rgba(255,255,255,0.8))';
            
            svg.appendChild(marker);
            highlightMarker = marker;
        }
    }
    
    function clearHighlight() {
        const svg = document.getElementById('wheel');
        
        // Restore all cells
        svg.querySelectorAll('path[data-dim]').forEach(path => {
            path.style.opacity = '1';
        });
        
        // Remove marker
        if (highlightMarker) {
            highlightMarker.remove();
            highlightMarker = null;
        }
    }
    
    function showCellInfo(dim, layer) {
        const info = DIMENSIONS[dim];
        const score = data[dim][layer];
        const displayScore = toDisplayScore(score);
        const isStrong = score >= THRESHOLD;
        
        document.getElementById('cell-name').textContent = `${dim}${layer}: ${info.name}`;
        document.getElementById('cell-name').style.color = getCategoryColor(info.category);
        document.getElementById('cell-detail').textContent = `Layer ${layer}: ${LAYERS[layer]} • ${info.category}`;
        document.getElementById('cell-score').textContent = displayScore.toFixed(1);
        
        const statusEl = document.getElementById('cell-status');
        statusEl.textContent = isStrong ? `STRONG (≥${DISPLAY_THRESHOLD})` : `WEAK (<${DISPLAY_THRESHOLD})`;
        statusEl.className = 'cell-status ' + (isStrong ? 'strong' : 'weak');
    }
    
    function renderBreaksList() {
        const container = document.getElementById('breaks-list');
        container.innerHTML = '';
        
        DIM_ORDER.forEach(dim => {
            const info = DIMENSIONS[dim];
            const { floor, break: breakPoint } = findBreakPoint(data[dim]);
            
            const item = document.createElement('div');
            item.className = 'break-item';
            
            let layerText, layerClass;
            if (breakPoint === null) {
                layerText = 'Solid';
                layerClass = 'solid';
            } else if (breakPoint === 1) {
                layerText = 'L1 Crisis';
                layerClass = 'crisis';
            } else {
                layerText = `L${breakPoint} ${LAYERS[breakPoint]}`;
                layerClass = '';
            }
            
            item.innerHTML = `
                <span class="dim ${info.category.toLowerCase()}">${dim} ${info.name}</span>
                <span class="layer ${layerClass}">${layerText}</span>
            `;
            
            // Hover events
            item.addEventListener('mouseenter', () => {
                highlightDimension(dim, breakPoint);
            });
            item.addEventListener('mouseleave', () => {
                clearHighlight();
            });
            
            container.appendChild(item);
        });
    }
    
    function randomize() {
        generateData();
        renderWheel();
        document.getElementById('status').textContent = 'Data randomized';
        setTimeout(() => document.getElementById('status').textContent = '', 2000);
    }
    
    // Init
    generateData();
    renderWheel();
    
    // Keyboard shortcut
    document.addEventListener('keydown', (e) => {
        if (e.key === 'r') randomize();
    });
    </script>
</body>
</html>
